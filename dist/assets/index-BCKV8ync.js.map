{"version":3,"mappings":"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","names":["useSettings","settings","userData","useEffect","root","_a","fontSizes","_b","_c","initializeSettingsFromStorage","stored","e","neonUrl","neonClient","neon","query","sql","params","error","queries","executeQuery","queryName","handleDatabaseError","getUser","userId","getProfile","getProfilesByIds","userIds","getUserWithProfile","createClerkUser","id","email","phone","first_name","last_name","username","profile_photo_url","account_types","active_role","bio","zip_code","ensureUserInDatabase","existingUser","defaultUserData","updateProfile","updates","clerkUserFields","profileFields","fieldMappings","clerkUpdates","profileUpdates","key","value","mappedKey","fields","values","paramIndex","upsertSubProfile","accountType","data","displayName","photo_url","restOfData","profileData","getSubProfile","getSubProfiles","deleteSubProfile","retryError","getPosts","limit","offset","createPost","postData","user_id","content","media","mentions","hashtags","location","visibility","display_name","author_photo","posted_as_role","updatePost","postId","deletePost","getComments","createComment","commentData","post_id","parent_id","deleteComment","commentId","updatePostCommentCount","increment","updatePostSaveCount","checkIsSaved","savePost","saveData","author_id","author_name","preview","has_media","unsavePost","getFollowing","f","getFollowers","followUser","followerId","followingId","unfollowUser","getFollowingCount","getFollowersCount","getBookings","options","status","updateBookingStatus","bookingId","metadata","getMarketplaceItems","category","getGearListings","createGearListing","listingData","seller_id","title","description","price","condition","images","brand","model","updateGearListingStatus","listingId","getGearOrders","createGearOrder","orderData","listing_id","buyer_id","total_price","updateGearOrderStatus","orderId","createGearOffer","offerData","offeror_id","recipient_id","offer_amount","message","respondToGearOffer","offerId","response","getSafeExchangeTransactions","getSafeExchangeTransactionById","transactionId","createSafeExchangeTransaction","transactionData","order_id","amount","itemId","transactionType","parties","itemDetails","verificationData","finalOrderId","finalBuyerId","finalSellerId","finalAmount","finalEscrowStatus","updateSafeExchangeTransaction","i","addTransactionPhoto","photoData","createMarketplaceItemSeshFx","itemData","type","downloadUrl","tags","author","getUserLibrary","addToUserLibrary","getDistributionReleases","createDistributionRelease","releaseData","tracks","artworkUrl","releaseDate","primaryArtist","upc","isrcCode","updateDistributionRelease","releaseId","deleteDistributionRelease","getWalletBalance","upsertWallet","balance","getNotifications","unreadOnly","createNotification","notificationData","markNotificationAsRead","notificationId","markAllNotificationsAsRead","deleteNotification","clearAllNotifications","getExternalArtists","labelId","createExternalArtist","artistData","name","stage_name","genre","primary_role","social_links","contract_type","signed_date","getLabelMetrics","getStudioMetrics","studioId","getDistributionMetrics","getEquipmentGrouped","items","grouped","item","getPendingSubmissions","createEquipmentSubmission","submission","updateSubmissionVotes","submissionId","votes","approveEquipmentSubmission","verifiedBy","sub","equipment","rejectEquipmentSubmission","AuthWizard","lazy","AppRoutes","MainLayout","App","clerkLoaded","isSignedIn","useAuth","user","useUser","clerk","useClerk","setUserData","useState","loading","setLoading","navigate","useNavigate","useLocation","darkMode","setDarkMode","storedSettings","toggleTheme","isMounted","userWithProfile","finalUserData","minimalUserData","_d","_e","_f","err","_g","handleLogout","useCallback","jsx","Loader2","isFromSignup","isAuthenticated","hasUserData","isOnLoginPage","isTestLoginPage","Suspense","LanguageProvider","jsxs","Toaster","clerkPubKey","clerkConfig","Sentry","sentryLoadAttempted","initSentry","dsn","sentryModule","n","init","BrowserTracing","Replay","hub","logError","errorInfo","context","errorData","sentry","storedErrors","ErrorBoundary","React","props","__publicField","currentPath","errorText","loggedError","phrases","AlertTriangle","Fragment","Check","Copy","RefreshCw","sentryDsn","Sentry.init","Sentry.browserTracingIntegration","Sentry.replayIntegration","Sentry.extraErrorDataIntegration","Sentry.captureConsoleIntegration","event","hint","_h","AppWrapper","children","Sentry.ErrorBoundary","resetError","ReactDOM","ClerkProvider","ConvexProvider","convex","BrowserRouter","removeLoader","loader"],"ignoreList":[],"sources":["../../src/hooks/useSettings.js","../../src/config/neon.js","../../src/config/neonQueries.js","../../src/App.jsx","../../src/config/clerk.js","../../src/utils/errorReporting.js","../../src/components/shared/ErrorBoundary.jsx","../../src/main.jsx"],"sourcesContent":["import { useEffect } from 'react';\r\n\r\n/**\r\n * Hook to apply user settings immediately on the client side\r\n * This hook watches for settings changes and applies them to the DOM/CSS\r\n */\r\nexport function useSettings(settings, userData) {\r\n  useEffect(() => {\r\n    if (!settings) return;\r\n\r\n    // Apply theme\r\n    if (settings.theme) {\r\n      const root = document.documentElement;\r\n      if (settings.theme === 'system') {\r\n        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n        if (prefersDark) {\r\n          root.classList.add('dark');\r\n          localStorage.setItem('theme', 'dark');\r\n        } else {\r\n          root.classList.remove('dark');\r\n          localStorage.setItem('theme', 'light');\r\n        }\r\n      } else if (settings.theme === 'dark') {\r\n        root.classList.add('dark');\r\n        localStorage.setItem('theme', 'dark');\r\n      } else {\r\n        root.classList.remove('dark');\r\n        localStorage.setItem('theme', 'light');\r\n      }\r\n    }\r\n\r\n    // Apply font size\r\n    if (settings.accessibility?.fontSize) {\r\n      const root = document.documentElement;\r\n      const fontSizes = {\r\n        small: '14px',\r\n        medium: '16px',\r\n        large: '18px',\r\n        xlarge: '20px',\r\n      };\r\n      root.style.fontSize = fontSizes[settings.accessibility.fontSize] || fontSizes.medium;\r\n      localStorage.setItem('fontSize', settings.accessibility.fontSize);\r\n    }\r\n\r\n    // Apply reduced motion\r\n    if (settings.accessibility?.reducedMotion !== undefined) {\r\n      const root = document.documentElement;\r\n      if (settings.accessibility.reducedMotion) {\r\n        root.classList.add('reduce-motion');\r\n        root.style.setProperty('--motion-duration', '0s');\r\n      } else {\r\n        root.classList.remove('reduce-motion');\r\n        root.style.removeProperty('--motion-duration');\r\n      }\r\n      localStorage.setItem('reducedMotion', settings.accessibility.reducedMotion);\r\n    }\r\n\r\n    // Apply high contrast\r\n    if (settings.accessibility?.highContrast !== undefined) {\r\n      const root = document.documentElement;\r\n      if (settings.accessibility.highContrast) {\r\n        root.classList.add('high-contrast');\r\n      } else {\r\n        root.classList.remove('high-contrast');\r\n      }\r\n      localStorage.setItem('highContrast', settings.accessibility.highContrast);\r\n    }\r\n\r\n    // Apply language\r\n    if (settings.language) {\r\n      document.documentElement.lang = settings.language;\r\n      localStorage.setItem('language', settings.language);\r\n    }\r\n\r\n    // Apply timezone\r\n    if (settings.timezone && settings.timezone !== 'auto') {\r\n      localStorage.setItem('timezone', settings.timezone);\r\n    }\r\n\r\n    // Apply currency\r\n    if (settings.currency) {\r\n      localStorage.setItem('currency', settings.currency);\r\n    }\r\n\r\n    // Apply date/time formats\r\n    if (settings.dateFormat) {\r\n      localStorage.setItem('dateFormat', settings.dateFormat);\r\n    }\r\n    if (settings.timeFormat) {\r\n      localStorage.setItem('timeFormat', settings.timeFormat);\r\n    }\r\n\r\n    // Apply number format\r\n    if (settings.numberFormat) {\r\n      localStorage.setItem('numberFormat', settings.numberFormat);\r\n    }\r\n\r\n    // Store all settings in localStorage for persistence\r\n    localStorage.setItem('userSettings', JSON.stringify(settings));\r\n\r\n  }, [settings]);\r\n}\r\n\r\n/**\r\n * Initialize settings from localStorage on app load\r\n */\r\nexport function initializeSettingsFromStorage() {\r\n  if (typeof window === 'undefined') return null;\r\n\r\n  const stored = localStorage.getItem('userSettings');\r\n  if (stored) {\r\n    try {\r\n      return JSON.parse(stored);\r\n    } catch (e) {\r\n      console.error('Failed to parse stored settings:', e);\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Format date according to user's preference\r\n */\r\nexport function formatDate(date, format = null) {\r\n  if (!date) return '';\r\n  \r\n  const storedFormat = format || localStorage.getItem('dateFormat') || 'MM/DD/YYYY';\r\n  const d = new Date(date);\r\n  \r\n  if (isNaN(d.getTime())) return date;\r\n\r\n  const day = String(d.getDate()).padStart(2, '0');\r\n  const month = String(d.getMonth() + 1).padStart(2, '0');\r\n  const year = d.getFullYear();\r\n\r\n  switch (storedFormat) {\r\n    case 'DD/MM/YYYY':\r\n      return `${day}/${month}/${year}`;\r\n    case 'YYYY-MM-DD':\r\n      return `${year}-${month}-${day}`;\r\n    default:\r\n      return `${month}/${day}/${year}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Format time according to user's preference\r\n */\r\nexport function formatTime(date, format = null) {\r\n  if (!date) return '';\r\n  \r\n  const storedFormat = format || localStorage.getItem('timeFormat') || '12h';\r\n  const d = new Date(date);\r\n  \r\n  if (isNaN(d.getTime())) return date;\r\n\r\n  let hours = d.getHours();\r\n  const minutes = String(d.getMinutes()).padStart(2, '0');\r\n\r\n  if (storedFormat === '24h') {\r\n    return `${String(hours).padStart(2, '0')}:${minutes}`;\r\n  } else {\r\n    const ampm = hours >= 12 ? 'PM' : 'AM';\r\n    hours = hours % 12 || 12;\r\n    return `${hours}:${minutes} ${ampm}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Format currency according to user's preference\r\n */\r\nexport function formatCurrency(amount, currency = null) {\r\n  const storedCurrency = currency || localStorage.getItem('currency') || 'USD';\r\n  const storedFormat = localStorage.getItem('numberFormat') || '1,000.00';\r\n  \r\n  const formatter = new Intl.NumberFormat('en-US', {\r\n    style: 'currency',\r\n    currency: storedCurrency,\r\n    minimumFractionDigits: 2,\r\n    maximumFractionDigits: 2,\r\n  });\r\n\r\n  let formatted = formatter.format(amount);\r\n  \r\n  // Apply number format preference\r\n  if (storedFormat === '1.000,00') {\r\n    formatted = formatted.replace(/,/g, 'TEMP').replace(/\\./g, ',').replace(/TEMP/g, '.');\r\n  } else if (storedFormat === '1 000.00') {\r\n    formatted = formatted.replace(/,/g, ' ');\r\n  }\r\n\r\n  return formatted;\r\n}\r\n\r\n","/**\r\n * Neon PostgreSQL Configuration\r\n *\r\n * This module configures the Neon PostgreSQL client for database operations.\r\n * Neon is a serverless PostgreSQL database with automatic branching and scaling.\r\n *\r\n * Environment Variables Required:\r\n * - VITE_NEON_DATABASE_URL: Neon connection string (postgresql://...)\r\n * - VITE_NEON_POOLER_URL: Neon pooler connection string (optional, for better connection pooling)\r\n *\r\n * Neon Console: https://console.neon.tech/\r\n * Documentation: https://neon.tech/docs\r\n *\r\n * @example\r\n * import { neonClient, query } from '@/config/neon';\r\n *\r\n * // Execute a query\r\n * const result = await query(\r\n *   'SELECT * FROM clerk_users WHERE id = $1',\r\n *   [userId]\r\n * );\r\n */\r\n\r\nimport { neon } from '@neondatabase/serverless';\r\n\r\n// =====================================================\r\n// NEON CONNECTION STRING\r\n// =====================================================\r\n\r\nconst neonUrl = import.meta.env.VITE_NEON_DATABASE_URL;\r\n\r\nif (!neonUrl) {\r\n  if (import.meta.env.DEV) {\r\n    console.error(\r\n      '❌ Neon: VITE_NEON_DATABASE_URL is not set. ' +\r\n      'Database operations will not work. Get your connection string from https://console.neon.tech/'\r\n    );\r\n  } else {\r\n    console.error('❌ Neon: Missing database connection string in production');\r\n  }\r\n}\r\n\r\n/**\r\n * Neon SQL Client\r\n *\r\n * Uses the Neon serverless driver for optimal performance in serverless\r\n * environments (Vercel, AWS Lambda, etc.).\r\n *\r\n * The serverless driver uses HTTP instead of WebSockets, making it\r\n * suitable for edge functions and serverless platforms.\r\n */\r\nexport const neonClient = neonUrl ? neon(neonUrl) : null;\r\n\r\n/**\r\n * Check if Neon is properly configured\r\n *\r\n * @returns {boolean} True if Neon connection string is present\r\n */\r\nexport function isNeonConfigured() {\r\n  return !!neonUrl;\r\n}\r\n\r\n/**\r\n * Execute a SQL query\r\n *\r\n * @param {string} sql - SQL query with optional placeholders ($1, $2, etc.)\r\n * @param {Array} params - Parameter values for placeholders\r\n * @returns {Promise<Array>} Query results\r\n *\r\n * @example\r\n * // Simple query\r\n * const users = await query('SELECT * FROM clerk_users');\r\n *\r\n * // Query with parameters\r\n * const user = await query(\r\n *   'SELECT * FROM clerk_users WHERE id = $1',\r\n *   [userId]\r\n * );\r\n *\r\n * // Insert\r\n * await query(\r\n *   'INSERT INTO posts (user_id, content) VALUES ($1, $2)',\r\n *   [userId, content]\r\n * );\r\n */\r\nexport async function query(sql, params = []) {\r\n  if (!neonClient) {\r\n    throw new Error('Neon client is not configured. Check VITE_NEON_DATABASE_URL environment variable.');\r\n  }\r\n\r\n  try {\r\n    const result = await neonClient(sql, params);\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Neon query error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Common queries with predefined SQL\r\n */\r\nexport const queries = {\r\n  // User queries\r\n  getUserById: 'SELECT * FROM clerk_users WHERE id = $1',\r\n  getUserByEmail: 'SELECT * FROM clerk_users WHERE email = $1',\r\n  getUserByUsername: 'SELECT * FROM clerk_users WHERE username = $1',\r\n\r\n  // Profile queries\r\n  getProfileByUserId: 'SELECT * FROM profiles WHERE user_id = $1',\r\n  getActiveProfile: `\r\n    SELECT p.*, cu.active_role, cu.account_types\r\n    FROM profiles p\r\n    JOIN clerk_users cu ON p.user_id = cu.id\r\n    WHERE p.user_id = $1\r\n  `,\r\n\r\n  // Social feed queries\r\n  getPosts: `\r\n    SELECT p.*, cu.username, cu.email, sp.display_name, sp.photo_url\r\n    FROM posts p\r\n    JOIN clerk_users cu ON p.user_id = cu.id\r\n    LEFT JOIN profiles sp ON sp.user_id = cu.id\r\n    WHERE p.deleted_at IS NULL\r\n    ORDER BY p.created_at DESC\r\n    LIMIT $1\r\n  `,\r\n  getPostsByUser: `\r\n    SELECT * FROM posts\r\n    WHERE user_id = $1 AND deleted_at IS NULL\r\n    ORDER BY created_at DESC\r\n    LIMIT $2\r\n  `,\r\n  getPostById: 'SELECT * FROM posts WHERE id = $1',\r\n\r\n  // Comments\r\n  getCommentsByPostId: `\r\n    SELECT c.*, cu.username, sp.display_name, sp.photo_url\r\n    FROM comments c\r\n    JOIN clerk_users cu ON c.user_id = cu.id\r\n    LEFT JOIN profiles sp ON sp.user_id = cu.id\r\n    WHERE c.post_id = $1 AND c.deleted_at IS NULL\r\n    ORDER BY c.created_at ASC\r\n  `,\r\n\r\n  // Notifications\r\n  getNotificationsByUserId: `\r\n    SELECT * FROM notifications\r\n    WHERE user_id = $1\r\n    ORDER BY created_at DESC\r\n    LIMIT $2\r\n  `,\r\n  getUnreadNotificationsCount: `\r\n    SELECT COUNT(*) as count\r\n    FROM notifications\r\n    WHERE user_id = $1 AND read = false\r\n  `,\r\n\r\n  // Bookings\r\n  getBookingsByUser: `\r\n    SELECT * FROM bookings\r\n    WHERE (sender_id = $1 OR target_id = $1)\r\n    ORDER BY created_at DESC\r\n    LIMIT $2\r\n  `,\r\n  getBookingById: 'SELECT * FROM bookings WHERE id = $1',\r\n\r\n  // Marketplace\r\n  getMarketItems: `\r\n    SELECT mi.*, cu.username, sp.display_name\r\n    FROM market_items mi\r\n    JOIN clerk_users cu ON mi.seller_id = cu.id\r\n    LEFT JOIN profiles sp ON sp.user_id = cu.id\r\n    WHERE mi.status = 'active'\r\n    ORDER BY mi.created_at DESC\r\n    LIMIT $1\r\n  `,\r\n};\r\n\r\n/**\r\n * Helper to execute predefined queries\r\n *\r\n * @param {string} queryName - Name of the query from `queries` object\r\n * @param {Array} params - Parameters for the query\r\n * @returns {Promise<Array>} Query results\r\n *\r\n * @example\r\n * const user = await executeQuery('getUserById', [userId]);\r\n * const posts = await executeQuery('getPosts', [50]);\r\n */\r\nexport async function executeQuery(queryName, params = []) {\r\n  const sql = queries[queryName];\r\n\r\n  if (!sql) {\r\n    throw new Error(`Query \"${queryName}\" not found.`);\r\n  }\r\n\r\n  return query(sql, params);\r\n}\r\n\r\n/**\r\n * Development Notice\r\n *\r\n * During development, if you see warnings about missing environment variables:\r\n * 1. Go to https://console.neon.tech/\r\n * 2. Create a new project or select an existing one\r\n * 3. Copy the connection string (Connection Details > Connection string)\r\n * 4. Add it to your .env.local file:\r\n *\r\n *    VITE_NEON_DATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/database?sslmode=require\r\n *\r\n * For production, ensure the environment variable is set in your hosting platform\r\n * (Vercel, Netlify, etc.).\r\n */\r\n\r\n// =====================================================\r\n// ADVANCED TRANSACTION HELPERS\r\n// =====================================================\r\n\r\n/**\r\n * Execute multiple queries in a transaction (using serverless driver)\r\n *\r\n * Note: The Neon serverless driver doesn't support traditional transactions.\r\n * This function executes queries sequentially and rolls back manually if needed.\r\n *\r\n * For true ACID transactions, use the postgres package with connection pooling.\r\n *\r\n * @param {Function} callback - Function that receives query function and performs operations\r\n * @returns {Promise<any>} Result of the callback function\r\n *\r\n * @example\r\n * const result = await transaction(async (tx) => {\r\n *   const post = await tx('INSERT INTO posts (user_id, content) VALUES ($1, $2) RETURNING *', [userId, content]);\r\n *   await tx('UPDATE profiles SET posts_count = posts_count + 1 WHERE user_id = $1', [userId]);\r\n *   return post;\r\n * });\r\n */\r\nexport async function transaction(callback) {\r\n  if (!neonClient) {\r\n    throw new Error('Neon client is not configured.');\r\n  }\r\n\r\n  const executedQueries = [];\r\n\r\n  try {\r\n    // Create a transaction-aware query function\r\n    const txQuery = async (sql, params) => {\r\n      const result = await neonClient(sql, params);\r\n      executedQueries.push({ sql, params, result });\r\n      return result;\r\n    };\r\n\r\n    // Execute the callback with our transaction-aware query function\r\n    const result = await callback(txQuery);\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Transaction failed, executed queries:', executedQueries);\r\n    console.error('Transaction error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Transaction builder for complex operations\r\n *\r\n * Provides a cleaner API for building complex transactions.\r\n *\r\n * @returns {object} Transaction builder\r\n *\r\n * @example\r\n * const result = await createTransaction()\r\n *   .query('INSERT INTO posts (user_id, content) VALUES ($1, $2) RETURNING *', [userId, content])\r\n *   .query('UPDATE profiles SET posts_count = posts_count + 1 WHERE user_id = $1', [userId])\r\n *   .query('INSERT INTO audit_log (user_id, action) VALUES ($1, $2)', [userId, 'post_created'])\r\n *   .execute();\r\n */\r\nexport function createTransaction() {\r\n  const queries = [];\r\n\r\n  return {\r\n    /**\r\n     * Add a query to the transaction\r\n     *\r\n     * @param {string} sql - SQL query\r\n     * @param {Array} params - Query parameters\r\n     * @returns {object} Transaction builder (for chaining)\r\n     */\r\n    query(sql, params = []) {\r\n      queries.push({ sql, params });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Execute all queries in the transaction\r\n     *\r\n     * @returns {Promise<Array>} Array of query results\r\n     */\r\n    async execute() {\r\n      if (!neonClient) {\r\n        throw new Error('Neon client is not configured.');\r\n      }\r\n\r\n      const results = [];\r\n\r\n      try {\r\n        for (const { sql, params } of queries) {\r\n          const result = await neonClient(sql, params);\r\n          results.push(result);\r\n        }\r\n\r\n        return results;\r\n      } catch (error) {\r\n        console.error('Transaction execution failed:', error);\r\n        console.error('Queries that were executed:', queries);\r\n        throw error;\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Batch query executor\r\n *\r\n * Executes multiple queries in parallel for better performance.\r\n *\r\n * @param {Array} queryList - Array of { sql, params } objects\r\n * @returns {Promise<Array>} Array of query results\r\n *\r\n * @example\r\n * const results = await batchQueries([\r\n *   { sql: 'SELECT * FROM posts WHERE user_id = $1', params: [userId] },\r\n *   { sql: 'SELECT * FROM profiles WHERE user_id = $1', params: [userId] },\r\n *   { sql: 'SELECT COUNT(*) as count FROM notifications WHERE user_id = $1', params: [userId] }\r\n * ]);\r\n */\r\nexport async function batchQueries(queryList) {\r\n  if (!neonClient) {\r\n    throw new Error('Neon client is not configured.');\r\n  }\r\n\r\n  try {\r\n    const promises = queryList.map(({ sql, params }) =>\r\n      neonClient(sql, params || [])\r\n    );\r\n\r\n    const results = await Promise.all(promises);\r\n    return results;\r\n  } catch (error) {\r\n    console.error('Batch query error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Query with retry logic\r\n *\r\n * Retries a query if it fails due to transient errors.\r\n *\r\n * @param {string} sql - SQL query\r\n * @param {Array} params - Query parameters\r\n * @param {object} options - Retry options\r\n * @returns {Promise<Array>} Query results\r\n *\r\n * @example\r\n * const result = await queryWithRetry(\r\n *   'SELECT * FROM posts WHERE id = $1',\r\n *   [postId],\r\n *   { maxRetries: 3, retryDelay: 1000 }\r\n * );\r\n */\r\nexport async function queryWithRetry(sql, params = [], options = {}) {\r\n  const {\r\n    maxRetries = 3,\r\n    retryDelay = 1000,\r\n    backoffMultiplier = 2,\r\n  } = options;\r\n\r\n  let lastError;\r\n\r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await query(sql, params);\r\n    } catch (error) {\r\n      lastError = error;\r\n\r\n      // Don't retry on certain errors\r\n      if (error.code === '23505') { // Unique constraint violation\r\n        throw error;\r\n      }\r\n\r\n      if (attempt < maxRetries) {\r\n        const delay = retryDelay * Math.pow(backoffMultiplier, attempt);\r\n        console.warn(`Query failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries})`);\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n  }\r\n\r\n  throw lastError;\r\n}\r\n\r\n/**\r\n * Paginated query helper\r\n *\r\n * Executes a paginated query with automatic limit/offset handling.\r\n *\r\n * @param {string} baseSql - Base SQL query (without LIMIT/OFFSET)\r\n * @param {Array} params - Query parameters\r\n * @param {object} options - Pagination options\r\n * @returns {Promise<object>} Paginated results\r\n *\r\n * @example\r\n * const { data, pagination } = await paginatedQuery(\r\n *   'SELECT * FROM posts WHERE user_id = $1',\r\n *   [userId],\r\n *   { page: 2, pageSize: 20 }\r\n * );\r\n */\r\nexport async function paginatedQuery(baseSql, params = [], options = {}) {\r\n  const {\r\n    page = 1,\r\n    pageSize = 20,\r\n    orderBy = 'created_at',\r\n    orderDirection = 'DESC',\r\n  } = options;\r\n\r\n  const offset = (page - 1) * pageSize;\r\n\r\n  // Get total count\r\n  const countSql = baseSql.replace(/SELECT.*?FROM/i, 'SELECT COUNT(*) as total FROM');\r\n  const countResult = await query(countSql, params);\r\n  const total = parseInt(countResult[0]?.total || '0', 10);\r\n\r\n  // Get paginated data\r\n  const dataSql = `${baseSql} ORDER BY ${orderBy} ${orderDirection} LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;\r\n  const data = await query(dataSql, [...params, pageSize, offset]);\r\n\r\n  return {\r\n    data,\r\n    pagination: {\r\n      page,\r\n      pageSize,\r\n      total,\r\n      totalPages: Math.ceil(total / pageSize),\r\n      hasNext: page * pageSize < total,\r\n      hasPrev: page > 1,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Health check for Neon connection\r\n *\r\n * @returns {Promise<boolean>} True if connection is healthy\r\n */\r\nexport async function healthCheck() {\r\n  try {\r\n    await query('SELECT 1 as health_check');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Neon health check failed:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Get database connection info\r\n *\r\n * @returns {Promise<object>} Connection information\r\n */\r\nexport async function getConnectionInfo() {\r\n  try {\r\n    const result = await query(`\r\n      SELECT\r\n        version(),\r\n        now() as current_time,\r\n        inet_server_addr() as server_ip,\r\n        inet_server_port() as server_port\r\n    `);\r\n\r\n    return {\r\n      connected: true,\r\n      version: result[0]?.version,\r\n      serverTime: result[0]?.current_time,\r\n      serverIp: result[0]?.server_ip,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      connected: false,\r\n      error: error.message,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Query performance monitor\r\n *\r\n * Monitors and logs slow queries for performance optimization.\r\n *\r\n * @param {string} sql - SQL query\r\n * @param {Array} params - Query parameters\r\n * @param {number} slowThreshold - Threshold in ms for \"slow\" queries (default: 1000ms)\r\n * @returns {Promise<Array>} Query results\r\n *\r\n * @example\r\n * const result = await monitoredQuery(\r\n *   'SELECT * FROM posts WHERE user_id = $1',\r\n *   [userId],\r\n *   500 // Log queries that take more than 500ms\r\n * );\r\n */\r\nexport async function monitoredQuery(sql, params = [], slowThreshold = 1000) {\r\n  const startTime = performance.now();\r\n\r\n  try {\r\n    const result = await query(sql, params);\r\n\r\n    const duration = performance.now() - startTime;\r\n    if (duration > slowThreshold) {\r\n      console.warn(`Slow query detected (${duration.toFixed(2)}ms):`, sql);\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    const duration = performance.now() - startTime;\r\n    console.error(`Query failed after ${duration.toFixed(2)}ms:`, sql, error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Upsert helper (Insert or Update)\r\n *\r\n * Performs an upsert operation based on the table's unique constraints.\r\n *\r\n * @param {string} tableName - Table name\r\n * @param {object} data - Data to insert/update\r\n * @param {string} conflictTarget - Column name(s) for conflict detection\r\n * @param {object} updateData - Data to update on conflict (optional, defaults to all data)\r\n * @returns {Promise<object>} Upserted row\r\n *\r\n * @example\r\n * const result = await upsert(\r\n *   'profiles',\r\n *   { user_id: userId, display_name: 'John', bio: 'Musician' },\r\n *   'user_id'\r\n * );\r\n */\r\nexport async function upsert(tableName, data, conflictTarget, updateData = null) {\r\n  const columns = Object.keys(data);\r\n  const values = Object.values(data);\r\n  const placeholders = columns.map((_, i) => `$${i + 1}`).join(', ');\r\n\r\n  const updateColumns = updateData ? Object.keys(updateData) : columns;\r\n  const updateSets = updateColumns\r\n    .map(col => `${col} = EXCLUDED.${col}`)\r\n    .join(', ');\r\n\r\n  const sql = `\r\n    INSERT INTO ${tableName} (${columns.join(', ')})\r\n    VALUES (${placeholders})\r\n    ON CONFLICT (${conflictTarget}) DO UPDATE SET\r\n      ${updateSets || updateColumns.map(col => `${col} = EXCLUDED.${col}`).join(', ')},\r\n      updated_at = NOW()\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await query(sql, values);\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Bulk insert helper\r\n *\r\n * Inserts multiple rows in a single query.\r\n *\r\n * @param {string} tableName - Table name\r\n * @param {Array} dataArray - Array of data objects to insert\r\n * @returns {Promise<Array>} Inserted rows\r\n *\r\n * @example\r\n * const results = await bulkInsert('notifications', [\r\n *   { user_id: userId, type: 'like', message: 'Someone liked your post' },\r\n *   { user_id: userId, type: 'follow', message: 'Someone followed you' }\r\n * ]);\r\n */\r\nexport async function bulkInsert(tableName, dataArray) {\r\n  if (dataArray.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const columns = Object.keys(dataArray[0]);\r\n  const placeholders = dataArray.map((_, rowIndex) =>\r\n    columns.map((_, colIndex) => `$${rowIndex * columns.length + colIndex + 1}`).join(', ')\r\n  );\r\n\r\n  const values = dataArray.flatMap(row => Object.values(row));\r\n\r\n  const sql = `\r\n    INSERT INTO ${tableName} (${columns.join(', ')})\r\n    VALUES (${placeholders.join('), (')})\r\n    RETURNING *\r\n  `;\r\n\r\n  return query(sql, values);\r\n}\r\n","/**\r\n * Neon Centralized Query Library\r\n *\r\n * This module provides a comprehensive set of query functions for all database operations.\r\n * It replaces Supabase queries with Neon queries throughout the application.\r\n *\r\n * Features:\r\n * - Centralized query definitions\r\n * - Type-safe parameter handling\r\n * - Common query patterns\r\n * - Business-specific query helpers\r\n *\r\n * @example\r\n * import { getUser, createPost, getBookings } from '@/config/neonQueries';\r\n *\r\n * const user = await getUser(userId);\r\n * const posts = await getPosts({ limit: 50, userId });\r\n * const bookings = await getBookings(userId);\r\n */\r\n\r\nimport { neonClient } from './neon';\r\n\r\n// =====================================================\r\n// ERROR HANDLING\r\n// =====================================================\r\n\r\n/**\r\n * Handle and log database errors\r\n *\r\n * @param {Error} error - Database error\r\n * @param {string} queryName - Name of the query that failed\r\n * @throws {Error} Re-throws the error with additional context\r\n */\r\nfunction handleDatabaseError(error, queryName) {\r\n  console.error(`Database error in ${queryName}:`, error);\r\n  throw new Error(`Query ${queryName} failed: ${error.message}`);\r\n}\r\n\r\n/**\r\n * Execute a SQL query with error handling\r\n *\r\n * @param {string} sql - SQL query\r\n * @param {Array} params - Query parameters\r\n * @param {string} queryName - Name for error tracking\r\n * @returns {Promise<Array>} Query results\r\n */\r\nasync function executeQuery(sql, params = [], queryName = 'Unnamed Query') {\r\n  if (!neonClient) {\r\n    throw new Error('Neon client is not configured');\r\n  }\r\n\r\n  try {\r\n    const result = await neonClient(sql, params);\r\n    return result;\r\n  } catch (error) {\r\n    handleDatabaseError(error, queryName);\r\n  }\r\n}\r\n\r\n// =====================================================\r\n// USER AND PROFILE QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get user by ID\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<object|null>} User object or null\r\n *\r\n * @example\r\n * const user = await getUser('user_12345');\r\n */\r\nexport async function getUser(userId) {\r\n  const result = await executeQuery(\r\n    'SELECT * FROM clerk_users WHERE id = $1',\r\n    [userId],\r\n    'getUser'\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get user by email\r\n *\r\n * @param {string} email - User email\r\n * @returns {Promise<object|null>} User object or null\r\n */\r\nexport async function getUserByEmail(email) {\r\n  const result = await executeQuery(\r\n    'SELECT * FROM clerk_users WHERE email = $1',\r\n    [email],\r\n    'getUserByEmail'\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get user by username\r\n *\r\n * @param {string} username - Username\r\n * @returns {Promise<object|null>} User object or null\r\n */\r\nexport async function getUserByUsername(username) {\r\n  const result = await executeQuery(\r\n    'SELECT * FROM clerk_users WHERE username = $1',\r\n    [username],\r\n    'getUserByUsername'\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get profile by user ID\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<object|null>} Profile object or null\r\n */\r\nexport async function getProfile(userId) {\r\n  const result = await executeQuery(\r\n    'SELECT * FROM profiles WHERE user_id = $1',\r\n    [userId],\r\n    'getProfile'\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get multiple profiles by user IDs\r\n *\r\n * @param {Array<string>} userIds - Array of user IDs\r\n * @returns {Promise<Array>} Array of profiles\r\n */\r\nexport async function getProfilesByIds(userIds) {\r\n  if (!userIds || userIds.length === 0) return [];\r\n\r\n  const sql = 'SELECT * FROM profiles WHERE user_id = ANY($1)';\r\n  const result = await executeQuery(sql, [userIds], 'getProfilesByIds');\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get user with profile\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<object|null>} User with profile or null\r\n */\r\nexport async function getUserWithProfile(userId) {\r\n  const result = await executeQuery(\r\n    `SELECT\r\n      cu.id,\r\n      cu.email,\r\n      cu.phone,\r\n      cu.first_name,\r\n      cu.last_name,\r\n      cu.username,\r\n      cu.profile_photo_url,\r\n      cu.account_types,\r\n      cu.active_role,\r\n      cu.bio as clerk_bio,\r\n      cu.zip_code,\r\n      cu.created_at,\r\n      cu.updated_at,\r\n      p.id as profile_id,\r\n      p.display_name,\r\n      p.photo_url as profile_photo_url,\r\n      p.bio as profile_bio,\r\n      p.location,\r\n      p.website,\r\n      p.social_links,\r\n      p.talent_info,\r\n      p.engineer_info,\r\n      p.producer_info,\r\n      p.studio_info,\r\n      p.education_info,\r\n      p.label_info,\r\n      p.followers_count,\r\n      p.following_count,\r\n      p.posts_count,\r\n      p.reputation_score\r\n    FROM clerk_users cu\r\n    LEFT JOIN profiles p ON p.user_id = cu.id\r\n    WHERE cu.id = $1`,\r\n    [userId],\r\n    'getUserWithProfile'\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create clerk user\r\n *\r\n * @param {object} userData - User data from Clerk\r\n * @returns {Promise<object>} Created user\r\n */\r\nexport async function createClerkUser(userData) {\r\n  const {\r\n    id,\r\n    email,\r\n    phone = null,\r\n    first_name = null,\r\n    last_name = null,\r\n    username = null,\r\n    profile_photo_url = null,\r\n    account_types = ['Fan'],\r\n    active_role = 'Fan',\r\n    bio = null,\r\n    zip_code = null,\r\n  } = userData;\r\n\r\n  const sql = `\r\n    INSERT INTO clerk_users (\r\n      id, email, phone, first_name, last_name, username,\r\n      profile_photo_url, account_types, active_role, bio, zip_code\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\r\n    ON CONFLICT (id) DO UPDATE SET\r\n      email = EXCLUDED.email,\r\n      phone = EXCLUDED.phone,\r\n      first_name = EXCLUDED.first_name,\r\n      last_name = EXCLUDED.last_name,\r\n      username = EXCLUDED.username,\r\n      profile_photo_url = EXCLUDED.profile_photo_url,\r\n      updated_at = NOW()\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [id, email, phone, first_name, last_name, username, profile_photo_url, account_types, active_role, bio, zip_code],\r\n    'createClerkUser'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Ensure user exists in database (fallback for webhook sync)\r\n *\r\n * This function checks if a user exists in clerk_users table.\r\n * If not, it creates the user with data from Clerk.\r\n * This is a fallback in case the webhook hasn't run yet.\r\n *\r\n * @param {string} userId - Clerk user ID\r\n * @param {object} userData - User data from Clerk (optional)\r\n * @returns {Promise<object>} User object\r\n */\r\nexport async function ensureUserInDatabase(userId, userData = null) {\r\n  // First check if user exists\r\n  const existingUser = await getUser(userId);\r\n\r\n  if (existingUser) {\r\n    return existingUser;\r\n  }\r\n\r\n  // User doesn't exist, create them\r\n  console.log('User not found in database, creating:', userId);\r\n\r\n  // If no userData provided, create minimal user\r\n  const defaultUserData = userData || {\r\n    id: userId,\r\n    email: `${userId}@clerk.tmp`, // Temporary email\r\n    account_types: ['Fan'],\r\n    active_role: 'Fan'\r\n  };\r\n\r\n  return await createClerkUser(defaultUserData);\r\n}\r\n\r\n/**\r\n * Update profile\r\n *\r\n * @param {string} userId - User ID\r\n * @param {object} updates - Profile updates\r\n * @returns {Promise<object>} Updated profile data\r\n */\r\nexport async function updateProfile(userId, updates) {\r\n  // Fields that go in clerk_users table\r\n  const clerkUserFields = ['first_name', 'last_name', 'username', 'profile_photo_url', 'bio', 'zip_code',\r\n                          'account_types', 'active_role', 'default_profile_role', 'settings',\r\n                          'display_name', 'effective_display_name'];\r\n\r\n  // Fields that go in profiles table\r\n  const profileFields = ['location', 'website', 'social_links', 'photo_url', 'cover_photo_url',\r\n                        'talent_info', 'engineer_info', 'producer_info', 'studio_info', 'education_info', 'label_info',\r\n                        'profile_visibility', 'messaging_permission', 'hourly_rate', 'use_legal_name_only',\r\n                        'use_user_name_only', 'search_terms'];\r\n\r\n  // Field name mappings (frontend -> database)\r\n  const fieldMappings = {\r\n    'zip': 'zip_code',\r\n    'avatar_url': 'photo_url',\r\n    'banner_url': 'cover_photo_url',\r\n    'hourlyRate': 'hourly_rate',\r\n    'useLegalNameOnly': 'use_legal_name_only',\r\n    'useUserNameOnly': 'use_user_name_only',\r\n    'searchTerms': 'search_terms'\r\n  };\r\n\r\n  const clerkUpdates = {};\r\n  const profileUpdates = {};\r\n\r\n  for (const [key, value] of Object.entries(updates)) {\r\n    // Map field name if there's a mapping\r\n    const mappedKey = fieldMappings[key] || key;\r\n\r\n    if (clerkUserFields.includes(mappedKey)) {\r\n      clerkUpdates[mappedKey] = value;\r\n    } else if (profileFields.includes(mappedKey)) {\r\n      profileUpdates[mappedKey] = value;\r\n    }\r\n  }\r\n\r\n  // Update clerk_users if needed\r\n  if (Object.keys(clerkUpdates).length > 0) {\r\n    const fields = [];\r\n    const values = [];\r\n    let paramIndex = 1;\r\n\r\n    for (const [key, value] of Object.entries(clerkUpdates)) {\r\n      // Handle JSONB fields (settings is an object)\r\n      if (key === 'settings' && typeof value === 'object') {\r\n        fields.push(`${key} = $${paramIndex}::jsonb`);\r\n        values.push(JSON.stringify(value));\r\n      } else if (key === 'account_types' && Array.isArray(value)) {\r\n        fields.push(`${key} = $${paramIndex}::text[]`);\r\n        values.push(value);\r\n      } else {\r\n        fields.push(`${key} = $${paramIndex}`);\r\n        values.push(value);\r\n      }\r\n      paramIndex++;\r\n    }\r\n\r\n    values.push(userId);\r\n    const sql = `\r\n      UPDATE clerk_users\r\n      SET ${fields.join(', ')}, updated_at = NOW()\r\n      WHERE id = $${paramIndex}\r\n      RETURNING *\r\n    `;\r\n\r\n    await executeQuery(sql, values, 'updateClerkUser');\r\n  }\r\n\r\n  // Update profiles if needed\r\n  if (Object.keys(profileUpdates).length > 0) {\r\n    const fields = [];\r\n    const values = [];\r\n    let paramIndex = 1;\r\n\r\n    for (const [key, value] of Object.entries(profileUpdates)) {\r\n      if (typeof value === 'object' && value !== null) {\r\n        fields.push(`${key} = $${paramIndex}::jsonb`);\r\n        values.push(JSON.stringify(value));\r\n      } else {\r\n        fields.push(`${key} = $${paramIndex}`);\r\n        values.push(value);\r\n      }\r\n      paramIndex++;\r\n    }\r\n\r\n    values.push(userId);\r\n    const sql = `\r\n      UPDATE profiles\r\n      SET ${fields.join(', ')}, updated_at = NOW()\r\n      WHERE user_id = $${paramIndex}\r\n      RETURNING *\r\n    `;\r\n\r\n    const result = await executeQuery(sql, values, 'updateProfile');\r\n    return result[0];\r\n  }\r\n\r\n  // If only clerk_users was updated, fetch the updated profile\r\n  return await getProfile(userId);\r\n}\r\n\r\n/**\r\n * Upsert sub-profile\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} accountType - Account type (Talent, Studio, Label, etc.)\r\n * @param {object} data - Sub-profile data\r\n * @returns {Promise<object>} Upserted sub-profile\r\n */\r\nexport async function upsertSubProfile(userId, accountType, data) {\r\n  // Extract top-level fields for database columns\r\n  const { displayName, bio, photo_url, ...restOfData } = data;\r\n\r\n  // Convert remaining data to JSONB\r\n  const profileData = {\r\n    ...restOfData,\r\n    // Keep these in profile_data too for backward compatibility\r\n    displayName,\r\n    bio\r\n  };\r\n\r\n  const values = [\r\n    userId,\r\n    accountType,\r\n    displayName || null,\r\n    bio || null,\r\n    photo_url || null,\r\n    JSON.stringify(profileData),\r\n    new Date().toISOString()\r\n  ];\r\n\r\n  try {\r\n    const sql = `\r\n      INSERT INTO sub_profiles (user_id, account_type, display_name, bio, photo_url, profile_data, updated_at)\r\n      VALUES ($1, $2, $3, $4, $5, $6::jsonb, $7::timestamp)\r\n      ON CONFLICT (user_id, account_type)\r\n      DO UPDATE SET\r\n        display_name = $3,\r\n        bio = $4,\r\n        photo_url = $5,\r\n        profile_data = $6::jsonb,\r\n        updated_at = $7::timestamp\r\n      RETURNING *\r\n    `;\r\n\r\n    const result = await executeQuery(sql, values, 'upsertSubProfile');\r\n    return result[0];\r\n  } catch (error) {\r\n    // Handle UUID constraint errors gracefully\r\n    if (error.message && error.message.includes('invalid input syntax for type uuid')) {\r\n      console.error('UUID constraint error in upsertSubProfile:', error.message);\r\n      // Try with explicit cast\r\n      const sql = `\r\n        INSERT INTO sub_profiles (user_id, account_type, display_name, bio, photo_url, profile_data, updated_at)\r\n        VALUES ($1::text, $2, $3, $4, $5, $6::jsonb, $7::timestamp)\r\n        ON CONFLICT (user_id, account_type)\r\n        DO UPDATE SET\r\n          display_name = $3,\r\n          bio = $4,\r\n          photo_url = $5,\r\n          profile_data = $6::jsonb,\r\n          updated_at = $7::timestamp\r\n        RETURNING *\r\n      `;\r\n      const result = await executeQuery(sql, values, 'upsertSubProfile');\r\n      return result[0];\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get sub-profile\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} accountType - Account type\r\n * @returns {Promise<object|null>} Sub-profile or null\r\n */\r\nexport async function getSubProfile(userId, accountType) {\r\n  try {\r\n    const result = await executeQuery(\r\n      'SELECT * FROM sub_profiles WHERE user_id = $1 AND account_type = $2',\r\n      [userId, accountType],\r\n      'getSubProfile'\r\n    );\r\n    return result[0] || null;\r\n  } catch (error) {\r\n    if (error.message && error.message.includes('invalid input syntax for type uuid')) {\r\n      console.error('UUID constraint error in getSubProfile, retrying with cast:', error.message);\r\n      const result = await executeQuery(\r\n        'SELECT * FROM sub_profiles WHERE user_id::text = $1 AND account_type = $2',\r\n        [userId, accountType],\r\n        'getSubProfile'\r\n      );\r\n      return result[0] || null;\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all sub-profiles for user\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of sub-profiles\r\n */\r\nexport async function getSubProfiles(userId) {\r\n  try {\r\n    const result = await executeQuery(\r\n      'SELECT * FROM sub_profiles WHERE user_id = $1 ORDER BY account_type',\r\n      [userId],\r\n      'getSubProfiles'\r\n    );\r\n    return result;\r\n  } catch (error) {\r\n    if (error.message && error.message.includes('invalid input syntax for type uuid')) {\r\n      console.error('UUID constraint error in getSubProfiles, retrying with cast:', error.message);\r\n      const result = await executeQuery(\r\n        'SELECT * FROM sub_profiles WHERE user_id::text = $1 ORDER BY account_type',\r\n        [userId],\r\n        'getSubProfiles'\r\n      );\r\n      return result;\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Delete sub-profile\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} accountType - Account type to delete\r\n * @returns {Promise<boolean>} True if deleted\r\n */\r\nexport async function deleteSubProfile(userId, accountType) {\r\n  try {\r\n    const result = await executeQuery(\r\n      'DELETE FROM sub_profiles WHERE user_id = $1 AND account_type = $2 RETURNING *',\r\n      [userId, accountType],\r\n      'deleteSubProfile'\r\n    );\r\n    return result.length > 0;\r\n  } catch (error) {\r\n    // Handle UUID constraint errors gracefully\r\n    if (error.message && error.message.includes('invalid input syntax for type uuid')) {\r\n      console.error('UUID constraint error - this may be due to legacy database schema:', error.message);\r\n      // Try alternative approach without UUID comparison\r\n      try {\r\n        const result = await executeQuery(\r\n          'DELETE FROM sub_profiles WHERE user_id::text = $1 AND account_type = $2 RETURNING *',\r\n          [userId, accountType],\r\n          'deleteSubProfile'\r\n        );\r\n        return result.length > 0;\r\n      } catch (retryError) {\r\n        console.error('Retry also failed:', retryError.message);\r\n        throw retryError;\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Search users\r\n *\r\n * @param {object} options - Search options\r\n * @param {string} options.query - Search query\r\n * @param {number} options.limit - Result limit\r\n * @param {number} options.offset - Result offset\r\n * @returns {Promise<Array>} Array of users\r\n */\r\nexport async function searchUsers({ query, limit = 20, offset = 0 } = {}) {\r\n  const sql = `\r\n    SELECT\r\n      cu.id,\r\n      cu.username,\r\n      cu.email,\r\n      cu.account_types,\r\n      cu.active_role,\r\n      p.display_name,\r\n      p.photo_url,\r\n      p.bio\r\n    FROM clerk_users cu\r\n    LEFT JOIN profiles p ON p.user_id = cu.id\r\n    WHERE (\r\n      cu.username ILIKE $1 OR\r\n      cu.email ILIKE $1 OR\r\n      p.display_name ILIKE $1\r\n    )\r\n    AND cu.deleted_at IS NULL\r\n    ORDER BY cu.created_at DESC\r\n    LIMIT $2 OFFSET $3\r\n  `;\r\n\r\n  return executeQuery(sql, [`%${query}%`, limit, offset], 'searchUsers');\r\n}\r\n\r\n// =====================================================\r\n// SOCIAL FEED QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get posts\r\n *\r\n * @param {object} options - Query options\r\n * @param {number} options.limit - Number of posts to return\r\n * @param {string} options.userId - Filter by user ID\r\n * @param {number} options.offset - Offset for pagination\r\n * @returns {Promise<Array>} Array of posts\r\n */\r\nexport async function getPosts({ limit = 50, userId = null, offset = 0 } = {}) {\r\n  let sql = '';\r\n  let params = [];\r\n\r\n  if (userId) {\r\n    sql = `\r\n      SELECT\r\n        p.*,\r\n        cu.username,\r\n        cu.email,\r\n        cu.first_name,\r\n        cu.last_name,\r\n        cu.profile_photo_url,\r\n        prof.display_name,\r\n        prof.photo_url\r\n      FROM posts p\r\n      JOIN clerk_users cu ON p.user_id = cu.id\r\n      LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n      WHERE p.user_id = $1\r\n        AND p.deleted_at IS NULL\r\n      ORDER BY p.created_at DESC\r\n      LIMIT $2 OFFSET $3\r\n    `;\r\n    params = [userId, limit, offset];\r\n  } else {\r\n    sql = `\r\n      SELECT\r\n        p.*,\r\n        cu.username,\r\n        cu.email,\r\n        cu.first_name,\r\n        cu.last_name,\r\n        cu.profile_photo_url,\r\n        prof.display_name,\r\n        prof.photo_url\r\n      FROM posts p\r\n      JOIN clerk_users cu ON p.user_id = cu.id\r\n      LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n      WHERE p.deleted_at IS NULL\r\n      ORDER BY p.created_at DESC\r\n      LIMIT $1 OFFSET $2\r\n    `;\r\n    params = [limit, offset];\r\n  }\r\n\r\n  return executeQuery(sql, params, 'getPosts');\r\n}\r\n\r\n/**\r\n * Get post by ID\r\n *\r\n * @param {string} postId - Post ID\r\n * @returns {Promise<object|null>} Post object or null\r\n */\r\nexport async function getPost(postId) {\r\n  const sql = `\r\n    SELECT\r\n      p.*,\r\n      cu.username,\r\n      cu.email,\r\n      cu.first_name,\r\n      cu.last_name,\r\n      cu.profile_photo_url,\r\n      prof.display_name,\r\n      prof.photo_url\r\n    FROM posts p\r\n    JOIN clerk_users cu ON p.user_id = cu.id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE p.id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [postId], 'getPost');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create post\r\n *\r\n * @param {object} postData - Post data\r\n * @returns {Promise<object>} Created post\r\n */\r\nexport async function createPost(postData) {\r\n  const {\r\n    user_id,\r\n    content,\r\n    media = [],\r\n    mentions = [],\r\n    hashtags = [],\r\n    location = null,\r\n    visibility = 'public',\r\n    display_name = null,\r\n    author_photo = null,\r\n    posted_as_role = null,\r\n  } = postData;\r\n\r\n  const sql = `\r\n    INSERT INTO posts (\r\n      user_id, content, media, mentions, hashtags, location, visibility,\r\n      display_name, author_photo, posted_as_role\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [\r\n      user_id,\r\n      content,\r\n      JSON.stringify(media),\r\n      mentions,\r\n      hashtags,\r\n      location ? JSON.stringify(location) : null,\r\n      visibility,\r\n      display_name,\r\n      author_photo,\r\n      posted_as_role,\r\n    ],\r\n    'createPost'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update post\r\n *\r\n * @param {string} postId - Post ID\r\n * @param {object} updates - Post updates\r\n * @returns {Promise<object>} Updated post\r\n */\r\nexport async function updatePost(postId, updates) {\r\n  const fields = [];\r\n  const values = [];\r\n  let paramIndex = 1;\r\n\r\n  for (const [key, value] of Object.entries(updates)) {\r\n    if (typeof value === 'object') {\r\n      fields.push(`${key} = $${paramIndex}::jsonb`);\r\n      values.push(JSON.stringify(value));\r\n    } else {\r\n      fields.push(`${key} = $${paramIndex}`);\r\n      values.push(value);\r\n    }\r\n    paramIndex++;\r\n  }\r\n\r\n  if (fields.length === 0) {\r\n    throw new Error('No updates provided');\r\n  }\r\n\r\n  values.push(postId);\r\n  const sql = `\r\n    UPDATE posts\r\n    SET ${fields.join(', ')}, updated_at = NOW()\r\n    WHERE id = $${paramIndex}\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, values, 'updatePost');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Delete post (soft delete)\r\n *\r\n * @param {string} postId - Post ID\r\n * @returns {Promise<boolean>} True if deleted\r\n */\r\nexport async function deletePost(postId) {\r\n  const result = await executeQuery(\r\n    'UPDATE posts SET deleted_at = NOW() WHERE id = $1 RETURNING id',\r\n    [postId],\r\n    'deletePost'\r\n  );\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Get comments for post\r\n *\r\n * @param {string} postId - Post ID\r\n * @returns {Promise<Array>} Array of comments\r\n */\r\nexport async function getComments(postId) {\r\n  const sql = `\r\n    SELECT\r\n      c.*,\r\n      cu.username,\r\n      prof.display_name,\r\n      prof.photo_url\r\n    FROM comments c\r\n    JOIN clerk_users cu ON c.user_id = cu.id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE c.post_id = $1 AND c.deleted_at IS NULL\r\n    ORDER BY c.created_at ASC\r\n  `;\r\n\r\n  return executeQuery(sql, [postId], 'getComments');\r\n}\r\n\r\n/**\r\n * Create comment\r\n *\r\n * @param {object} commentData - Comment data\r\n * @returns {Promise<object>} Created comment\r\n */\r\nexport async function createComment(commentData) {\r\n  const {\r\n    post_id,\r\n    user_id,\r\n    content,\r\n    parent_id = null,\r\n    mentions = [],\r\n  } = commentData;\r\n\r\n  const sql = `\r\n    INSERT INTO comments (\r\n      post_id, user_id, content, parent_id, mentions\r\n    ) VALUES ($1, $2, $3, $4, $5)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [\r\n      post_id,\r\n      user_id,\r\n      content,\r\n      parent_id,\r\n      JSON.stringify(mentions),\r\n    ],\r\n    'createComment'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Delete comment\r\n *\r\n * @param {string} commentId - Comment ID\r\n * @returns {Promise<boolean>} True if deleted\r\n */\r\nexport async function deleteComment(commentId) {\r\n  const sql = `\r\n    UPDATE comments\r\n    SET deleted_at = NOW()\r\n    WHERE id = $1\r\n    RETURNING id\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [commentId], 'deleteComment');\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Update post comment count\r\n *\r\n * @param {string} postId - Post ID\r\n * @param {number} increment - Amount to increment (can be negative)\r\n * @returns {Promise<object>} Updated post\r\n */\r\nexport async function updatePostCommentCount(postId, increment) {\r\n  const sql = `\r\n    UPDATE posts\r\n    SET comment_count = GREATEST(comment_count + $1, 0),\r\n        updated_at = NOW()\r\n    WHERE id = $2\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [increment, postId], 'updatePostCommentCount');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update post save count\r\n *\r\n * @param {string} postId - Post ID\r\n * @param {number} increment - Amount to increment (can be negative)\r\n * @returns {Promise<object>} Updated post\r\n */\r\nexport async function updatePostSaveCount(postId, increment) {\r\n  const sql = `\r\n    UPDATE posts\r\n    SET save_count = GREATEST(save_count + $1, 0),\r\n        updated_at = NOW()\r\n    WHERE id = $2\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [increment, postId], 'updatePostSaveCount');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Check if post is saved by user\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} postId - Post ID\r\n * @returns {Promise<boolean>} True if post is saved\r\n */\r\nexport async function checkIsSaved(userId, postId) {\r\n  const sql = `\r\n    SELECT id FROM saved_posts\r\n    WHERE user_id = $1 AND post_id = $2\r\n    LIMIT 1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId, postId], 'checkIsSaved');\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Save a post\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} postId - Post ID\r\n * @param {object} saveData - Save data (author_id, author_name, preview, has_media)\r\n * @returns {Promise<object>} Created save record\r\n */\r\nexport async function savePost(userId, postId, saveData) {\r\n  const {\r\n    author_id,\r\n    author_name,\r\n    preview,\r\n    has_media = false\r\n  } = saveData;\r\n\r\n  const sql = `\r\n    INSERT INTO saved_posts (\r\n      user_id, post_id, author_id, author_name, preview, has_media, saved_at\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [userId, postId, author_id, author_name, preview, has_media],\r\n    'savePost'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Unsave a post\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} postId - Post ID\r\n * @returns {Promise<boolean>} True if unsaved\r\n */\r\nexport async function unsavePost(userId, postId) {\r\n  const sql = `\r\n    DELETE FROM saved_posts\r\n    WHERE user_id = $1 AND post_id = $2\r\n    RETURNING id\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId, postId], 'unsavePost');\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Get all saved posts for a user\r\n *\r\n * @param {string} userId - User ID\r\n * @param {number} limit - Maximum number of saved posts to return (default 50)\r\n * @returns {Promise<Array>} Array of saved post records\r\n */\r\nexport async function getSavedPosts(userId, limit = 50) {\r\n  const sql = `\r\n    SELECT\r\n      id,\r\n      post_id as \"postId\",\r\n      author_id as \"authorId\",\r\n      author_name as \"authorName\",\r\n      preview,\r\n      has_media as \"hasMedia\",\r\n      saved_at as \"savedAt\"\r\n    FROM saved_posts\r\n    WHERE user_id = $1\r\n    ORDER BY saved_at DESC\r\n    LIMIT $2\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId, limit], 'getSavedPosts');\r\n  return result;\r\n}\r\n\r\n// =====================================================\r\n// FOLLOW QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get users that the current user follows\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of following IDs\r\n */\r\nexport async function getFollowing(userId) {\r\n  const sql = `\r\n    SELECT following_id\r\n    FROM follows\r\n    WHERE follower_id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId], 'getFollowing');\r\n  return result.map(f => f.following_id);\r\n}\r\n\r\n/**\r\n * Get users that follow the current user\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of follower IDs\r\n */\r\nexport async function getFollowers(userId) {\r\n  const sql = `\r\n    SELECT follower_id\r\n    FROM follows\r\n    WHERE following_id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId], 'getFollowers');\r\n  return result.map(f => f.follower_id);\r\n}\r\n\r\n/**\r\n * Follow a user\r\n *\r\n * @param {string} followerId - User ID of the follower\r\n * @param {string} followingId - User ID to follow\r\n * @returns {Promise<object>} Created follow record\r\n */\r\nexport async function followUser(followerId, followingId) {\r\n  const sql = `\r\n    INSERT INTO follows (follower_id, following_id, created_at)\r\n    VALUES ($1, $2, NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [followerId, followingId], 'followUser');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Unfollow a user\r\n *\r\n * @param {string} followerId - User ID of the follower\r\n * @param {string} followingId - User ID to unfollow\r\n * @returns {Promise<boolean>} True if unfollowed\r\n */\r\nexport async function unfollowUser(followerId, followingId) {\r\n  const sql = `\r\n    DELETE FROM follows\r\n    WHERE follower_id = $1 AND following_id = $2\r\n    RETURNING id\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [followerId, followingId], 'unfollowUser');\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Get following count for a user\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<number>} Count of users following\r\n */\r\nexport async function getFollowingCount(userId) {\r\n  const sql = `\r\n    SELECT COUNT(*) as count\r\n    FROM follows\r\n    WHERE follower_id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId], 'getFollowingCount');\r\n  return result[0]?.count || 0;\r\n}\r\n\r\n/**\r\n * Get followers count for a user\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<number>} Count of followers\r\n */\r\nexport async function getFollowersCount(userId) {\r\n  const sql = `\r\n    SELECT COUNT(*) as count\r\n    FROM follows\r\n    WHERE following_id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId], 'getFollowersCount');\r\n  return result[0]?.count || 0;\r\n}\r\n\r\n// =====================================================\r\n// BOOKING QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get bookings for user\r\n *\r\n * @param {string} userId - User ID\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of bookings\r\n */\r\nexport async function getBookings(userId, options = {}) {\r\n  const { status = null, limit = 50, offset = 0 } = options;\r\n\r\n  let sql = `\r\n    SELECT b.*\r\n    FROM bookings b\r\n    WHERE (b.sender_id = $1 OR b.target_id = $1)\r\n  `;\r\n\r\n  const params = [userId];\r\n  let paramIndex = 2;\r\n\r\n  if (status) {\r\n    sql += ` AND b.status = $${paramIndex}`;\r\n    params.push(status);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY b.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\r\n  params.push(limit, offset);\r\n\r\n  return executeQuery(sql, params, 'getBookings');\r\n}\r\n\r\n/**\r\n * Get booking by ID\r\n *\r\n * @param {string} bookingId - Booking ID\r\n * @returns {Promise<object|null>} Booking object or null\r\n */\r\nexport async function getBooking(bookingId) {\r\n  const result = await executeQuery(\r\n    'SELECT * FROM bookings WHERE id = $1',\r\n    [bookingId],\r\n    'getBooking'\r\n  );\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create booking\r\n *\r\n * @param {object} bookingData - Booking data\r\n * @returns {Promise<object>} Created booking\r\n */\r\nexport async function createBooking(bookingData) {\r\n  const sql = `\r\n    INSERT INTO bookings (\r\n      sender_id, sender_name, target_id, target_name, type, service_type,\r\n      date, start_time, end_time, duration_hours, location, description,\r\n      message, budget_cap, agreed_price, logistics, attachments, metadata\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [\r\n      bookingData.sender_id,\r\n      bookingData.sender_name,\r\n      bookingData.target_id,\r\n      bookingData.target_name,\r\n      bookingData.type,\r\n      bookingData.service_type || null,\r\n      bookingData.date || null,\r\n      bookingData.start_time || null,\r\n      bookingData.end_time || null,\r\n      bookingData.duration_hours || null,\r\n      bookingData.location ? JSON.stringify(bookingData.location) : null,\r\n      bookingData.description || null,\r\n      bookingData.message || null,\r\n      bookingData.budget_cap || null,\r\n      bookingData.agreed_price || null,\r\n      bookingData.logistics || null,\r\n      bookingData.attachments ? JSON.stringify(bookingData.attachments) : '[]',\r\n      bookingData.metadata ? JSON.stringify(bookingData.metadata) : '{}',\r\n    ],\r\n    'createBooking'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update booking status\r\n *\r\n * @param {string} bookingId - Booking ID\r\n * @param {string} status - New status\r\n * @param {object} metadata - Additional metadata\r\n * @returns {Promise<object>} Updated booking\r\n */\r\nexport async function updateBookingStatus(bookingId, status, metadata = {}) {\r\n  const sql = `\r\n    UPDATE bookings\r\n    SET\r\n      status = $1,\r\n      metadata = COALESCE(metadata, '{}'::jsonb) || $2::jsonb,\r\n      updated_at = NOW()\r\n    WHERE id = $3\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [status, JSON.stringify(metadata), bookingId],\r\n    'updateBookingStatus'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n// =====================================================\r\n// MARKETPLACE QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get marketplace items\r\n *\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of items\r\n */\r\nexport async function getMarketplaceItems(options = {}) {\r\n  const {\r\n    category = null,\r\n    status = 'active',\r\n    limit = 50,\r\n    offset = 0,\r\n  } = options;\r\n\r\n  let sql = `\r\n    SELECT\r\n      mi.*,\r\n      cu.username,\r\n      prof.display_name,\r\n      prof.photo_url\r\n    FROM market_items mi\r\n    JOIN clerk_users cu ON mi.seller_id = cu.id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE mi.status = $1\r\n  `;\r\n\r\n  const params = [status];\r\n  let paramIndex = 2;\r\n\r\n  if (category) {\r\n    sql += ` AND mi.category = $${paramIndex}`;\r\n    params.push(category);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY mi.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\r\n  params.push(limit, offset);\r\n\r\n  return executeQuery(sql, params, 'getMarketplaceItems');\r\n}\r\n\r\n/**\r\n * Get marketplace item by ID\r\n *\r\n * @param {string} itemId - Item ID\r\n * @returns {Promise<object|null>} Item object or null\r\n */\r\nexport async function getMarketplaceItem(itemId) {\r\n  const sql = `\r\n    SELECT\r\n      mi.*,\r\n      cu.username,\r\n      prof.display_name,\r\n      prof.photo_url\r\n    FROM market_items mi\r\n    JOIN clerk_users cu ON mi.seller_id = cu.id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE mi.id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [itemId], 'getMarketplaceItem');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create marketplace item\r\n *\r\n * @param {object} itemData - Item data\r\n * @returns {Promise<object>} Created item\r\n */\r\nexport async function createMarketplaceItem(itemData) {\r\n  const sql = `\r\n    INSERT INTO market_items (\r\n      seller_id, title, description, category, subcategory, price,\r\n      condition, images, location, shipping_available, local_pickup_available,\r\n      metadata\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [\r\n      itemData.seller_id,\r\n      itemData.title,\r\n      itemData.description || null,\r\n      itemData.category,\r\n      itemData.subcategory || null,\r\n      itemData.price,\r\n      itemData.condition || null,\r\n      itemData.images ? JSON.stringify(itemData.images) : '[]',\r\n      itemData.location ? JSON.stringify(itemData.location) : null,\r\n      itemData.shipping_available !== false,\r\n      itemData.local_pickup_available !== false,\r\n      itemData.metadata ? JSON.stringify(itemData.metadata) : '{}',\r\n    ],\r\n    'createMarketplaceItem'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Search marketplace items\r\n *\r\n * @param {object} options - Search options\r\n * @returns {Promise<Array>} Array of items\r\n */\r\nexport async function searchMarketplaceItems(options = {}) {\r\n  const { query, category, minPrice, maxPrice, limit = 20, offset = 0 } = options;\r\n\r\n  let sql = `\r\n    SELECT mi.*\r\n    FROM market_items mi\r\n    WHERE mi.status = 'active'\r\n  `;\r\n\r\n  const params = [];\r\n  let paramIndex = 1;\r\n\r\n  if (query) {\r\n    sql += ` AND (mi.title ILIKE $${paramIndex} OR mi.description ILIKE $${paramIndex})`;\r\n    params.push(`%${query}%`);\r\n    paramIndex++;\r\n  }\r\n\r\n  if (category) {\r\n    sql += ` AND mi.category = $${paramIndex}`;\r\n    params.push(category);\r\n    paramIndex++;\r\n  }\r\n\r\n  if (minPrice) {\r\n    sql += ` AND mi.price >= $${paramIndex}`;\r\n    params.push(minPrice);\r\n    paramIndex++;\r\n  }\r\n\r\n  if (maxPrice) {\r\n    sql += ` AND mi.price <= $${paramIndex}`;\r\n    params.push(maxPrice);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY mi.created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\r\n  params.push(limit, offset);\r\n\r\n  return executeQuery(sql, params, 'searchMarketplaceItems');\r\n}\r\n\r\n// =====================================================\r\n// GEAR EXCHANGE QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get gear listings\r\n *\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of gear listings\r\n */\r\nexport async function getGearListings({ limit = 50, offset = 0, status = null } = {}) {\r\n  let sql = `SELECT * FROM gear_listings WHERE deleted_at IS NULL`;\r\n  const params = [];\r\n  let paramIndex = 1;\r\n\r\n  if (status) {\r\n    sql += ` AND status = $${paramIndex}`;\r\n    params.push(status);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\r\n  params.push(limit, offset);\r\n\r\n  return executeQuery(sql, params, 'getGearListings');\r\n}\r\n\r\n/**\r\n * Get gear listing by ID\r\n *\r\n * @param {string} listingId - Listing ID\r\n * @returns {Promise<object|null>} Listing object or null\r\n */\r\nexport async function getGearListingById(listingId) {\r\n  const sql = `SELECT * FROM gear_listings WHERE id = $1 AND deleted_at IS NULL`;\r\n  const result = await executeQuery(sql, [listingId], 'getGearListingById');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create gear listing\r\n *\r\n * @param {object} listingData - Listing data\r\n * @returns {Promise<object>} Created listing\r\n */\r\nexport async function createGearListing(listingData) {\r\n  const {\r\n    seller_id,\r\n    title,\r\n    description,\r\n    price,\r\n    condition,\r\n    images = [],\r\n    category,\r\n    brand,\r\n    model\r\n  } = listingData;\r\n\r\n  const sql = `\r\n    INSERT INTO gear_listings (\r\n      seller_id, title, description, price, condition, images, category, brand, model, status, created_at\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'active', NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [seller_id, title, description, price, condition, JSON.stringify(images), category, brand, model],\r\n    'createGearListing'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update gear listing status\r\n *\r\n * @param {string} listingId - Listing ID\r\n * @param {string} status - New status\r\n * @returns {Promise<object>} Updated listing\r\n */\r\nexport async function updateGearListingStatus(listingId, status) {\r\n  const sql = `UPDATE gear_listings SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *`;\r\n  const result = await executeQuery(sql, [status, listingId], 'updateGearListingStatus');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get gear orders\r\n *\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of gear orders\r\n */\r\nexport async function getGearOrders({ userId, status }) {\r\n  let sql = `SELECT * FROM gear_orders WHERE (buyer_id = $1 OR seller_id = $1)`;\r\n  const params = [userId];\r\n  let paramIndex = 2;\r\n\r\n  if (status) {\r\n    sql += ` AND status = $${paramIndex}`;\r\n    params.push(status);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY created_at DESC`;\r\n\r\n  return executeQuery(sql, params, 'getGearOrders');\r\n}\r\n\r\n/**\r\n * Create gear order\r\n *\r\n * @param {object} orderData - Order data\r\n * @returns {Promise<object>} Created order\r\n */\r\nexport async function createGearOrder(orderData) {\r\n  const { listing_id, buyer_id, seller_id, total_price } = orderData;\r\n\r\n  const sql = `\r\n    INSERT INTO gear_orders (listing_id, buyer_id, seller_id, total_price, status, created_at)\r\n    VALUES ($1, $2, $3, $4, 'pending', NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [listing_id, buyer_id, seller_id, total_price], 'createGearOrder');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update gear order status\r\n *\r\n * @param {string} orderId - Order ID\r\n * @param {string} status - New status\r\n * @returns {Promise<object>} Updated order\r\n */\r\nexport async function updateGearOrderStatus(orderId, status) {\r\n  const sql = `UPDATE gear_orders SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *`;\r\n  const result = await executeQuery(sql, [status, orderId], 'updateGearOrderStatus');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get gear offers\r\n *\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of gear offers\r\n */\r\nexport async function getGearOffers({ listingId, userId }) {\r\n  let sql = `SELECT * FROM gear_offers WHERE `;\r\n  const params = [];\r\n\r\n  if (listingId) {\r\n    sql += `listing_id = $1`;\r\n    params.push(listingId);\r\n  } else if (userId) {\r\n    sql += `(offeror_id = $1 OR recipient_id = $1)`;\r\n    params.push(userId);\r\n  } else {\r\n    // Return empty array if no filter provided\r\n    return [];\r\n  }\r\n\r\n  sql += ` ORDER BY created_at DESC`;\r\n\r\n  return executeQuery(sql, params, 'getGearOffers');\r\n}\r\n\r\n/**\r\n * Create gear offer\r\n *\r\n * @param {object} offerData - Offer data\r\n * @returns {Promise<object>} Created offer\r\n */\r\nexport async function createGearOffer(offerData) {\r\n  const { listing_id, offeror_id, recipient_id, offer_amount, message } = offerData;\r\n\r\n  const sql = `\r\n    INSERT INTO gear_offers (listing_id, offeror_id, recipient_id, offer_amount, message, status, created_at)\r\n    VALUES ($1, $2, $3, $4, $5, 'pending', NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [listing_id, offeror_id, recipient_id, offer_amount, message], 'createGearOffer');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Respond to gear offer\r\n *\r\n * @param {string} offerId - Offer ID\r\n * @param {string} response - Response ('accepted' or 'rejected')\r\n * @returns {Promise<object>} Updated offer\r\n */\r\nexport async function respondToGearOffer(offerId, response) {\r\n  const sql = `UPDATE gear_offers SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *`;\r\n  const result = await executeQuery(sql, [response, offerId], 'respondToGearOffer');\r\n  return result[0] || null;\r\n}\r\n\r\n// =====================================================\r\n// SAFE EXCHANGE QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get safe exchange transactions\r\n *\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of transactions\r\n */\r\nexport async function getSafeExchangeTransactions({ userId, status }) {\r\n  let sql = `SELECT * FROM safe_exchange_transactions WHERE buyer_id = $1 OR seller_id = $1`;\r\n  const params = [userId];\r\n  let paramIndex = 2;\r\n\r\n  if (status) {\r\n    sql += ` AND escrow_status = $${paramIndex}`;\r\n    params.push(status);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY created_at DESC`;\r\n\r\n  return executeQuery(sql, params, 'getSafeExchangeTransactions');\r\n}\r\n\r\n/**\r\n * Get safe exchange transaction by ID\r\n *\r\n * @param {string} transactionId - Transaction ID\r\n * @returns {Promise<object|null>} Transaction object or null\r\n */\r\nexport async function getSafeExchangeTransactionById(transactionId) {\r\n  const sql = `SELECT * FROM safe_exchange_transactions WHERE id = $1`;\r\n  const result = await executeQuery(sql, [transactionId], 'getSafeExchangeTransactionById');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create safe exchange transaction\r\n *\r\n * @param {object} transactionData - Transaction data\r\n * @returns {Promise<object>} Created transaction\r\n */\r\nexport async function createSafeExchangeTransaction(transactionData) {\r\n  // Support both old format (order_id, buyer_id, seller_id, amount)\r\n  // and new format (itemId, transactionType, parties, itemDetails, verificationData, status)\r\n  const {\r\n    order_id,\r\n    buyer_id,\r\n    seller_id,\r\n    amount,\r\n    itemId,\r\n    transactionType,\r\n    parties,\r\n    itemDetails,\r\n    verificationData,\r\n    status\r\n  } = transactionData;\r\n\r\n  // If new format is used, extract the data\r\n  const finalOrderId = order_id || null;\r\n  const finalBuyerId = buyer_id || parties?.buyer;\r\n  const finalSellerId = seller_id || parties?.seller;\r\n  const finalAmount = amount || itemDetails?.buyerTotal || verificationData?.escrowAmount;\r\n  const finalEscrowStatus = verificationData?.escrowStatus || 'pending';\r\n  const photoVerification = verificationData ? { verificationData } : null;\r\n\r\n  const sql = `\r\n    INSERT INTO safe_exchange_transactions (order_id, buyer_id, seller_id, amount, escrow_status, photo_verification, created_at)\r\n    VALUES ($1, $2, $3, $4, $5, $6, NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [finalOrderId, finalBuyerId, finalSellerId, finalAmount, finalEscrowStatus, JSON.stringify(photoVerification)],\r\n    'createSafeExchangeTransaction'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update safe exchange transaction\r\n *\r\n * @param {string} transactionId - Transaction ID\r\n * @param {object} updates - Fields to update\r\n * @returns {Promise<object>} Updated transaction\r\n */\r\nexport async function updateSafeExchangeTransaction(transactionId, updates) {\r\n  const fields = Object.keys(updates).map((key, i) => `${key} = $${i + 2}`).join(', ');\r\n  const values = Object.values(updates);\r\n  const sql = `UPDATE safe_exchange_transactions SET ${fields}, updated_at = NOW() WHERE id = $1 RETURNING *`;\r\n  const result = await executeQuery(sql, [transactionId, ...values], 'updateSafeExchangeTransaction');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Add transaction photo\r\n *\r\n * @param {string} transactionId - Transaction ID\r\n * @param {object} photoData - Photo data\r\n * @returns {Promise<object>} Updated transaction\r\n */\r\nexport async function addTransactionPhoto(transactionId, photoData) {\r\n  const sql = `\r\n    UPDATE safe_exchange_transactions\r\n    SET verification_data = jsonb_set(\r\n      COALESCE(verification_data, '{}'),\r\n      '{photos}',\r\n      COALESCE(verification_data->'photos', '[]'::jsonb) || $2::jsonb\r\n    ),\r\n    updated_at = NOW()\r\n    WHERE id = $1\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [transactionId, JSON.stringify([photoData])], 'addTransactionPhoto');\r\n  return result[0] || null;\r\n}\r\n\r\n// =====================================================\r\n// MARKETPLACE ITEMS (SeshFx) QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get marketplace items (SeshFx)\r\n *\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of marketplace items\r\n */\r\nexport async function getSeshFxStoreItems({ limit = 50, type } = {}) {\r\n  let sql = `SELECT * FROM marketplace_items WHERE deleted_at IS NULL`;\r\n  const params = [];\r\n  let paramIndex = 1;\r\n\r\n  if (type) {\r\n    sql += ` AND type = $${paramIndex}`;\r\n    params.push(type);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY created_at DESC LIMIT $${paramIndex}`;\r\n  params.push(limit);\r\n\r\n  return executeQuery(sql, params, 'getSeshFxStoreItems');\r\n}\r\n\r\n/**\r\n * Get marketplace item by ID (SeshFx)\r\n *\r\n * @param {string} itemId - Item ID\r\n * @returns {Promise<object|null>} Item object or null\r\n */\r\nexport async function getMarketplaceItemById(itemId) {\r\n  const sql = `SELECT * FROM marketplace_items WHERE id = $1 AND deleted_at IS NULL`;\r\n  const result = await executeQuery(sql, [itemId], 'getMarketplaceItemById');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create marketplace item (SeshFx)\r\n *\r\n * @param {object} itemData - Item data\r\n * @returns {Promise<object>} Created item\r\n */\r\nexport async function createMarketplaceItemSeshFx(itemData) {\r\n  const { userId, title, type, price, downloadUrl, tags, description, author } = itemData;\r\n\r\n  const sql = `\r\n    INSERT INTO marketplace_items (title, type, price, download_url, tags, description, author, author_id, created_at)\r\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [title, type, price, downloadUrl, tags, description, author, userId],\r\n    'createMarketplaceItemSeshFx'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Get user library\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of purchased items\r\n */\r\nexport async function getUserLibrary(userId) {\r\n  const sql = `\r\n    SELECT mi.*, ul.purchase_date\r\n    FROM user_library ul\r\n    JOIN marketplace_items mi ON ul.item_id = mi.id\r\n    WHERE ul.user_id = $1\r\n    ORDER BY ul.purchase_date DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [userId], 'getUserLibrary');\r\n}\r\n\r\n/**\r\n * Add to user library\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} itemId - Item ID\r\n * @returns {Promise<object>} Created library entry\r\n */\r\nexport async function addToUserLibrary(userId, itemId) {\r\n  const sql = `\r\n    INSERT INTO user_library (user_id, item_id, purchase_date)\r\n    VALUES ($1, $2, NOW())\r\n    ON CONFLICT (user_id, item_id) DO NOTHING\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId, itemId], 'addToUserLibrary');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Check item ownership\r\n *\r\n * @param {string} userId - User ID\r\n * @param {string} itemId - Item ID\r\n * @returns {Promise<boolean>} True if user owns item\r\n */\r\nexport async function checkItemOwnership(userId, itemId) {\r\n  const sql = `SELECT 1 FROM user_library WHERE user_id = $1 AND item_id = $2 LIMIT 1`;\r\n  const result = await executeQuery(sql, [userId, itemId], 'checkItemOwnership');\r\n  return result.length > 0;\r\n}\r\n\r\n// =====================================================\r\n// DISTRIBUTION RELEASES QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get distribution releases\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of releases\r\n */\r\nexport async function getDistributionReleases(userId) {\r\n  const sql = `SELECT * FROM distribution_releases WHERE uploader_id = $1 ORDER BY updated_at DESC`;\r\n  return executeQuery(sql, [userId], 'getDistributionReleases');\r\n}\r\n\r\n/**\r\n * Get distribution release by ID\r\n *\r\n * @param {string} releaseId - Release ID\r\n * @returns {Promise<object|null>} Release object or null\r\n */\r\nexport async function getDistributionReleaseById(releaseId) {\r\n  const sql = `SELECT * FROM distribution_releases WHERE id = $1`;\r\n  const result = await executeQuery(sql, [releaseId], 'getDistributionReleaseById');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Create distribution release\r\n *\r\n * @param {object} releaseData - Release data\r\n * @returns {Promise<object>} Created release\r\n */\r\nexport async function createDistributionRelease(releaseData) {\r\n  const {\r\n    userId,\r\n    title,\r\n    type,\r\n    tracks = [],\r\n    artworkUrl,\r\n    releaseDate,\r\n    primaryArtist,\r\n    upc,\r\n    isrcCode\r\n  } = releaseData;\r\n\r\n  const sql = `\r\n    INSERT INTO distribution_releases (\r\n      uploader_id, title, type, tracks, artwork_url, release_date, primary_artist, upc, isrc_code, status, created_at, updated_at\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'Draft', NOW(), NOW())\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [userId, title, type, JSON.stringify(tracks), artworkUrl, releaseDate, primaryArtist, upc, isrcCode],\r\n    'createDistributionRelease'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update distribution release\r\n *\r\n * @param {string} releaseId - Release ID\r\n * @param {object} updates - Fields to update\r\n * @returns {Promise<object>} Updated release\r\n */\r\nexport async function updateDistributionRelease(releaseId, updates) {\r\n  const fields = [];\r\n  const values = [];\r\n  let paramIndex = 1;\r\n\r\n  for (const [key, value] of Object.entries(updates)) {\r\n    if (['tracks', 'metadata'].includes(key)) {\r\n      fields.push(`${key} = $${paramIndex}::jsonb`);\r\n      values.push(JSON.stringify(value));\r\n    } else {\r\n      fields.push(`${key} = $${paramIndex}`);\r\n      values.push(value);\r\n    }\r\n    paramIndex++;\r\n  }\r\n\r\n  if (fields.length === 0) {\r\n    throw new Error('No updates provided');\r\n  }\r\n\r\n  values.push(releaseId);\r\n  const sql = `UPDATE distribution_releases SET ${fields.join(', ')}, updated_at = NOW() WHERE id = $${paramIndex} RETURNING *`;\r\n\r\n  const result = await executeQuery(sql, values, 'updateDistributionRelease');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Delete distribution release\r\n *\r\n * @param {string} releaseId - Release ID\r\n * @returns {Promise<boolean>} True if deleted\r\n */\r\nexport async function deleteDistributionRelease(releaseId) {\r\n  const sql = `DELETE FROM distribution_releases WHERE id = $1 AND status IN ('Draft', 'Action Needed')`;\r\n  const result = await executeQuery(sql, [releaseId], 'deleteDistributionRelease');\r\n  return result.length > 0;\r\n}\r\n\r\n// =====================================================\r\n// WALLET AND TRANSACTION QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get wallet balance\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<number>} Wallet balance\r\n */\r\nexport async function getWalletBalance(userId) {\r\n  const result = await executeQuery(\r\n    'SELECT balance FROM wallets WHERE user_id = $1',\r\n    [userId],\r\n    'getWalletBalance'\r\n  );\r\n  return result[0]?.balance || 0;\r\n}\r\n\r\n/**\r\n * Create or update wallet\r\n *\r\n * @param {string} userId - User ID\r\n * @param {number} balance - Wallet balance\r\n * @returns {Promise<object>} Wallet object\r\n */\r\nexport async function upsertWallet(userId, balance = 0) {\r\n  const sql = `\r\n    INSERT INTO wallets (user_id, balance)\r\n    VALUES ($1, $2)\r\n    ON CONFLICT (user_id) DO UPDATE SET\r\n      balance = GREATEST(0, wallets.balance + $2),\r\n      updated_at = NOW()\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId, balance], 'upsertWallet');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Create transaction\r\n *\r\n * @param {object} transactionData - Transaction data\r\n * @returns {Promise<object>} Created transaction\r\n */\r\nexport async function createTransaction(transactionData) {\r\n  const sql = `\r\n    INSERT INTO transactions (\r\n      user_id, wallet_id, type, amount, status, description,\r\n      reference_type, reference_id, payment_method, metadata\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [\r\n      transactionData.user_id,\r\n      transactionData.wallet_id || null,\r\n      transactionData.type,\r\n      transactionData.amount,\r\n      transactionData.status || 'pending',\r\n      transactionData.description || null,\r\n      transactionData.reference_type || null,\r\n      transactionData.reference_id || null,\r\n      transactionData.payment_method || null,\r\n      transactionData.metadata ? JSON.stringify(transactionData.metadata) : '{}',\r\n    ],\r\n    'createTransaction'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Get transactions for user\r\n *\r\n * @param {string} userId - User ID\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of transactions\r\n */\r\nexport async function getTransactions(userId, options = {}) {\r\n  const { type = null, limit = 50, offset = 0 } = options;\r\n\r\n  let sql = `\r\n    SELECT * FROM transactions\r\n    WHERE user_id = $1\r\n  `;\r\n\r\n  const params = [userId];\r\n  let paramIndex = 2;\r\n\r\n  if (type) {\r\n    sql += ` AND type = $${paramIndex}`;\r\n    params.push(type);\r\n    paramIndex++;\r\n  }\r\n\r\n  sql += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\r\n  params.push(limit, offset);\r\n\r\n  return executeQuery(sql, params, 'getTransactions');\r\n}\r\n\r\n// =====================================================\r\n// NOTIFICATION QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get notifications for user\r\n *\r\n * @param {string} userId - User ID\r\n * @param {object} options - Query options\r\n * @returns {Promise<Array>} Array of notifications\r\n */\r\nexport async function getNotifications(userId, options = {}) {\r\n  const { unreadOnly = false, limit = 50, offset = 0 } = options;\r\n\r\n  let sql = 'SELECT * FROM notifications WHERE user_id = $1';\r\n  const params = [userId];\r\n  let paramIndex = 2;\r\n\r\n  if (unreadOnly) {\r\n    sql += ' AND read = false';\r\n  }\r\n\r\n  sql += ' ORDER BY created_at DESC LIMIT $2 OFFSET $3';\r\n  params.push(limit, offset);\r\n\r\n  return executeQuery(sql, params, 'getNotifications');\r\n}\r\n\r\n/**\r\n * Get unread notification count\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<number>} Unread count\r\n */\r\nexport async function getUnreadNotificationCount(userId) {\r\n  const result = await executeQuery(\r\n    'SELECT COUNT(*) as count FROM notifications WHERE user_id = $1 AND read = false',\r\n    [userId],\r\n    'getUnreadNotificationCount'\r\n  );\r\n  return parseInt(result[0]?.count || '0', 10);\r\n}\r\n\r\n/**\r\n * Create notification\r\n *\r\n * @param {object} notificationData - Notification data\r\n * @returns {Promise<object>} Created notification\r\n */\r\nexport async function createNotification(notificationData) {\r\n  const sql = `\r\n    INSERT INTO notifications (\r\n      user_id, type, title, message, reference_type, reference_id, metadata\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [\r\n      notificationData.user_id,\r\n      notificationData.type,\r\n      notificationData.title || '',\r\n      notificationData.message || '',\r\n      notificationData.reference_type || null,\r\n      notificationData.reference_id || null,\r\n      notificationData.metadata ? JSON.stringify(notificationData.metadata) : '{}',\r\n    ],\r\n    'createNotification'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Mark notification as read\r\n *\r\n * @param {string} notificationId - Notification ID\r\n * @returns {Promise<boolean>} True if marked as read\r\n */\r\nexport async function markNotificationAsRead(notificationId) {\r\n  const result = await executeQuery(\r\n    'UPDATE notifications SET read = true, read_at = NOW() WHERE id = $1 RETURNING id',\r\n    [notificationId],\r\n    'markNotificationAsRead'\r\n  );\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Mark all notifications as read for user\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<number>} Number of notifications marked as read\r\n */\r\nexport async function markAllNotificationsAsRead(userId) {\r\n  const result = await executeQuery(\r\n    'UPDATE notifications SET read = true, read_at = NOW() WHERE user_id = $1 AND read = false RETURNING id',\r\n    [userId],\r\n    'markAllNotificationsAsRead'\r\n  );\r\n  return result.length;\r\n}\r\n\r\n/**\r\n * Delete notification (soft delete)\r\n *\r\n * @param {string} notificationId - Notification ID\r\n * @returns {Promise<boolean>} True if deleted\r\n */\r\nexport async function deleteNotification(notificationId) {\r\n  const result = await executeQuery(\r\n    'UPDATE notifications SET deleted = true WHERE id = $1 RETURNING id',\r\n    [notificationId],\r\n    'deleteNotification'\r\n  );\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Clear all notifications for user (soft delete)\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<number>} Number of notifications cleared\r\n */\r\nexport async function clearAllNotifications(userId) {\r\n  const result = await executeQuery(\r\n    'UPDATE notifications SET deleted = true WHERE user_id = $1 AND deleted = false RETURNING id',\r\n    [userId],\r\n    'clearAllNotifications'\r\n  );\r\n  return result.length;\r\n}\r\n\r\n// =====================================================\r\n// LABEL & BUSINESS QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get label roster\r\n *\r\n * @param {string} labelId - Label user ID\r\n * @returns {Promise<Array>} Array of roster entries\r\n */\r\nexport async function getLabelRoster(labelId) {\r\n  const sql = `\r\n    SELECT\r\n      lr.*,\r\n      cu.username as artist_username,\r\n      prof.display_name as artist_display_name,\r\n      prof.photo_url as artist_photo_url,\r\n      COALESCE(ds.lifetime_streams, 0) as streams,\r\n      COALESCE(ds.lifetime_earnings, 0) as earnings\r\n    FROM label_roster lr\r\n    JOIN clerk_users cu ON cu.id = lr.artist_id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    LEFT JOIN distribution_stats ds ON ds.user_id = lr.artist_id\r\n    WHERE lr.label_id = $1\r\n    ORDER BY lr.signed_date DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [labelId], 'getLabelRoster');\r\n}\r\n\r\n/**\r\n * Get releases for label\r\n *\r\n * @param {string} labelId - Label user ID\r\n * @returns {Promise<Array>} Array of releases\r\n */\r\nexport async function getLabelReleases(labelId) {\r\n  const sql = `\r\n    SELECT\r\n      r.*,\r\n      cu.username as artist_username,\r\n      prof.display_name as artist_display_name,\r\n      prof.photo_url as artist_photo_url\r\n    FROM releases r\r\n    JOIN clerk_users cu ON cu.id = r.artist_id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE r.label_id = $1\r\n    ORDER BY r.release_date DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [labelId], 'getLabelReleases');\r\n}\r\n\r\n/**\r\n * Get label dashboard metrics\r\n *\r\n * @param {string} labelId - Label user ID\r\n * @returns {Promise<object>} Dashboard metrics\r\n */\r\nexport async function getLabelDashboardMetrics(labelId) {\r\n  const sql = `\r\n    SELECT\r\n      (SELECT COUNT(*) FROM label_roster WHERE label_id = $1 AND status = 'active') as total_artists,\r\n      (SELECT COUNT(*) FROM releases WHERE label_id = $1 AND status = 'distributed') as total_releases,\r\n      (SELECT COALESCE(SUM(lifetime_earnings), 0) FROM distribution_stats WHERE user_id IN (\r\n        SELECT artist_id FROM label_roster WHERE label_id = $1\r\n      )) as total_revenue,\r\n      (SELECT COALESCE(SUM(lifetime_streams), 0) FROM distribution_stats WHERE user_id IN (\r\n        SELECT artist_id FROM label_roster WHERE label_id = $1\r\n      )) as total_streams\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [labelId], 'getLabelDashboardMetrics');\r\n  return result[0] || {\r\n    total_artists: 0,\r\n    total_releases: 0,\r\n    total_revenue: '0',\r\n    total_streams: '0',\r\n  };\r\n}\r\n\r\n/**\r\n * Get distribution stats for user\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of distribution stats\r\n */\r\nexport async function getDistributionStats(userId) {\r\n  const sql = `\r\n    SELECT\r\n      platform,\r\n      SUM(lifetime_streams) as total_streams,\r\n      SUM(lifetime_earnings) as total_earnings,\r\n      SUM(monthly_streams) as monthly_streams,\r\n      SUM(monthly_listeners) as monthly_listeners\r\n    FROM distribution_stats\r\n    WHERE user_id = $1\r\n    GROUP BY platform\r\n    ORDER BY total_earnings DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [userId], 'getDistributionStats');\r\n}\r\n\r\n/**\r\n * Add artist to label roster\r\n *\r\n * @param {string} labelId - Label user ID\r\n * @param {object} artistData - Artist data\r\n * @returns {Promise<object>} Created roster entry\r\n */\r\nexport async function addArtistToRoster(labelId, artistData) {\r\n  const {\r\n    artist_id,\r\n    name,\r\n    email,\r\n    photo_url,\r\n    role,\r\n    contract_type,\r\n    signed_date,\r\n    contract_end_date,\r\n    status = 'active',\r\n    notes,\r\n    metadata = {}\r\n  } = artistData;\r\n\r\n  const sql = `\r\n    INSERT INTO label_roster (\r\n      label_id, artist_id, name, email, photo_url,\r\n      role, contract_type, signed_date, contract_end_date,\r\n      status, notes, metadata\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12::jsonb)\r\n    ON CONFLICT (label_id, artist_id) DO UPDATE SET\r\n      name = EXCLUDED.name,\r\n      email = EXCLUDED.email,\r\n      photo_url = EXCLUDED.photo_url,\r\n      role = EXCLUDED.role,\r\n      contract_type = EXCLUDED.contract_type,\r\n      signed_date = EXCLUDED.signed_date,\r\n      contract_end_date = EXCLUDED.contract_end_date,\r\n      status = EXCLUDED.status,\r\n      notes = EXCLUDED.notes,\r\n      metadata = EXCLUDED.metadata,\r\n      updated_at = NOW()\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [labelId, artist_id, name, email, photo_url, role, contract_type, signed_date, contract_end_date, status, notes, JSON.stringify(metadata)],\r\n    'addArtistToRoster'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update roster entry\r\n *\r\n * @param {string} rosterId - Roster entry ID\r\n * @param {object} updates - Fields to update\r\n * @returns {Promise<object>} Updated roster entry\r\n */\r\nexport async function updateRosterEntry(rosterId, updates) {\r\n  const fields = [];\r\n  const values = [];\r\n  let paramIndex = 1;\r\n\r\n  for (const [key, value] of Object.entries(updates)) {\r\n    if (key === 'metadata') {\r\n      fields.push(`${key} = $${paramIndex}::jsonb`);\r\n      values.push(JSON.stringify(value));\r\n    } else {\r\n      fields.push(`${key} = $${paramIndex}`);\r\n      values.push(value);\r\n    }\r\n    paramIndex++;\r\n  }\r\n\r\n  if (fields.length === 0) {\r\n    throw new Error('No updates provided');\r\n  }\r\n\r\n  values.push(rosterId);\r\n  const sql = `\r\n    UPDATE label_roster\r\n    SET ${fields.join(', ')}, updated_at = NOW()\r\n    WHERE id = $${paramIndex}\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, values, 'updateRosterEntry');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Delete roster entry\r\n *\r\n * @param {string} rosterId - Roster entry ID\r\n * @param {string} labelId - Label ID (for verification)\r\n * @returns {Promise<boolean>} True if deleted\r\n */\r\nexport async function deleteRosterEntry(rosterId, labelId) {\r\n  // First verify the roster entry belongs to this label\r\n  const verifyResult = await executeQuery(\r\n    'SELECT id FROM label_roster WHERE id = $1 AND label_id = $2',\r\n    [rosterId, labelId],\r\n    'verifyRosterEntry'\r\n  );\r\n\r\n  if (!verifyResult || verifyResult.length === 0) {\r\n    throw new Error('Roster entry not found or access denied');\r\n  }\r\n\r\n  // Delete the entry\r\n  const result = await executeQuery(\r\n    'DELETE FROM label_roster WHERE id = $1 RETURNING id',\r\n    [rosterId],\r\n    'deleteRosterEntry'\r\n  );\r\n\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Check if artist is already on label's roster\r\n *\r\n * @param {string} labelId - Label ID\r\n * @param {string} artistId - Artist ID\r\n * @returns {Promise<boolean>} True if artist is on roster\r\n */\r\nexport async function isArtistOnRoster(labelId, artistId) {\r\n  const result = await executeQuery(\r\n    'SELECT id FROM label_roster WHERE label_id = $1 AND artist_id = $2',\r\n    [labelId, artistId],\r\n    'isArtistOnRoster'\r\n  );\r\n\r\n  return result.length > 0;\r\n}\r\n\r\n/**\r\n * Create release\r\n *\r\n * @param {object} releaseData - Release data\r\n * @returns {Promise<object>} Created release\r\n */\r\nexport async function createRelease(releaseData) {\r\n  const {\r\n    artist_id,\r\n    label_id,\r\n    title,\r\n    type,\r\n    genre,\r\n    release_date,\r\n    cover_art_url,\r\n    isrc,\r\n    upc,\r\n    platforms = {},\r\n    tracks = [],\r\n    status = 'draft',\r\n    distributor,\r\n    catalog_number\r\n  } = releaseData;\r\n\r\n  const sql = `\r\n    INSERT INTO releases (\r\n      artist_id, label_id, title, type, genre, release_date,\r\n      cover_art_url, isrc, upc, platforms, tracks, status,\r\n      distributor, catalog_number\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10::jsonb, $11::jsonb, $12, $13, $14)\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(\r\n    sql,\r\n    [artist_id, label_id, title, type, genre, release_date, cover_art_url, isrc, upc, JSON.stringify(platforms), JSON.stringify(tracks), status, distributor, catalog_number],\r\n    'createRelease'\r\n  );\r\n\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update release\r\n *\r\n * @param {string} releaseId - Release ID\r\n * @param {object} updates - Fields to update\r\n * @returns {Promise<object>} Updated release\r\n */\r\nexport async function updateRelease(releaseId, updates) {\r\n  const fields = [];\r\n  const values = [];\r\n  let paramIndex = 1;\r\n\r\n  for (const [key, value] of Object.entries(updates)) {\r\n    if (['platforms', 'tracks', 'metadata'].includes(key)) {\r\n      fields.push(`${key} = $${paramIndex}::jsonb`);\r\n      values.push(JSON.stringify(value));\r\n    } else {\r\n      fields.push(`${key} = $${paramIndex}`);\r\n      values.push(value);\r\n    }\r\n    paramIndex++;\r\n  }\r\n\r\n  if (fields.length === 0) {\r\n    throw new Error('No updates provided');\r\n  }\r\n\r\n  values.push(releaseId);\r\n  const sql = `\r\n    UPDATE releases\r\n    SET ${fields.join(', ')}, updated_at = NOW()\r\n    WHERE id = $${paramIndex}\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, values, 'updateRelease');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Get artist roster count\r\n *\r\n * @param {string} labelId - Label user ID\r\n * @returns {Promise<number>} Count of active artists\r\n */\r\nexport async function getArtistCount(labelId) {\r\n  const result = await executeQuery(\r\n    'SELECT COUNT(*) as count FROM label_roster WHERE label_id = $1 AND status = $2',\r\n    [labelId, 'active'],\r\n    'getArtistCount'\r\n  );\r\n  return parseInt(result[0]?.count || 0);\r\n}\r\n\r\n/**\r\n * Get upcoming releases\r\n *\r\n * @param {string} labelId - Label user ID\r\n * @param {number} limit - Number of releases to return\r\n * @returns {Promise<Array>} Array of upcoming releases\r\n */\r\nexport async function getUpcomingReleases(labelId, limit = 10) {\r\n  const sql = `\r\n    SELECT\r\n      r.*,\r\n      cu.username as artist_username,\r\n      prof.display_name as artist_display_name,\r\n      prof.photo_url as artist_photo_url\r\n    FROM releases r\r\n    JOIN clerk_users cu ON cu.id = r.artist_id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE r.label_id = $1\r\n      AND r.release_date >= CURRENT_DATE\r\n      AND r.status IN ('draft', 'submitted')\r\n    ORDER BY r.release_date ASC\r\n    LIMIT $2\r\n  `;\r\n\r\n  return executeQuery(sql, [labelId, limit], 'getUpcomingReleases');\r\n}\r\n\r\n/**\r\n * Search artists by name or email\r\n *\r\n * @param {string} query - Search query\r\n * @param {number} limit - Result limit\r\n * @returns {Promise<Array>} Array of artists\r\n */\r\nexport async function searchArtists(query, limit = 20) {\r\n  const sql = `\r\n    SELECT\r\n      cu.id,\r\n      cu.email,\r\n      cu.username,\r\n      cu.first_name,\r\n      cu.last_name,\r\n      cu.profile_photo_url,\r\n      cu.account_types,\r\n      p.display_name,\r\n      p.photo_url as profile_photo\r\n    FROM clerk_users cu\r\n    LEFT JOIN profiles p ON p.user_id = cu.id\r\n    WHERE (\r\n      cu.username ILIKE $1 OR\r\n      cu.email ILIKE $1 OR\r\n      p.display_name ILIKE $1 OR\r\n      (cu.first_name || ' ' || cu.last_name) ILIKE $1\r\n    )\r\n    AND cu.deleted_at IS NULL\r\n    AND cu.account_types @> ARRAY['Talent']::text[]\r\n    ORDER BY cu.created_at DESC\r\n    LIMIT $2\r\n  `;\r\n\r\n  return executeQuery(sql, [`%${query}%`, limit], 'searchArtists');\r\n}\r\n\r\n// =====================================================\r\n// EXTERNAL ARTIST QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get external artists for a label\r\n *\r\n * @param {string} labelId - Label ID\r\n * @returns {Promise<Array>} Array of external artists\r\n */\r\nexport async function getExternalArtists(labelId) {\r\n  const sql = `\r\n    SELECT * FROM external_artists\r\n    WHERE label_id = $1\r\n    ORDER BY created_at DESC\r\n  `;\r\n  return executeQuery(sql, [labelId], 'getExternalArtists');\r\n}\r\n\r\n/**\r\n * Create external artist\r\n *\r\n * @param {string} labelId - Label ID\r\n * @param {object} artistData - Artist data (name, email, stage_name, genre, primary_role, contract_type, signed_date)\r\n * @returns {Promise<object>} Created external artist\r\n */\r\nexport async function createExternalArtist(labelId, artistData) {\r\n  const {\r\n    name,\r\n    email,\r\n    phone,\r\n    stage_name,\r\n    genre = [],\r\n    primary_role,\r\n    social_links = {},\r\n    contract_type,\r\n    signed_date\r\n  } = artistData;\r\n\r\n  const sql = `\r\n    INSERT INTO external_artists (\r\n      label_id, name, email, phone, stage_name, genre, primary_role,\r\n      social_links, contract_type, signed_date, status\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'invited')\r\n    RETURNING *\r\n  `;\r\n\r\n  return executeQuery(\r\n    sql,\r\n    [\r\n      labelId,\r\n      name,\r\n      email || null,\r\n      phone || null,\r\n      stage_name || null,\r\n      JSON.stringify(genre),\r\n      primary_role || null,\r\n      JSON.stringify(social_links),\r\n      contract_type || null,\r\n      signed_date || null\r\n    ],\r\n    'createExternalArtist'\r\n  );\r\n}\r\n\r\n/**\r\n * Update external artist\r\n *\r\n * @param {string} artistId - External artist ID\r\n * @param {object} updates - Fields to update\r\n * @returns {Promise<object>} Updated external artist\r\n */\r\nexport async function updateExternalArtist(artistId, updates) {\r\n  const fields = [];\r\n  const values = [];\r\n  let paramIndex = 1;\r\n\r\n  for (const [key, value] of Object.entries(updates)) {\r\n    if (['social_links', 'metadata', 'genre'].includes(key)) {\r\n      fields.push(`${key} = $${paramIndex}::jsonb`);\r\n      values.push(JSON.stringify(value));\r\n    } else {\r\n      fields.push(`${key} = $${paramIndex}`);\r\n      values.push(value);\r\n    }\r\n    paramIndex++;\r\n  }\r\n\r\n  values.push(artistId);\r\n  const sql = `\r\n    UPDATE external_artists\r\n    SET ${fields.join(', ')}, updated_at = NOW()\r\n    WHERE id = $${paramIndex}\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, values, 'updateExternalArtist');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Invite external artist (generate invitation token)\r\n *\r\n * @param {string} artistId - External artist ID\r\n * @returns {Promise<object>} Updated external artist with token\r\n */\r\nexport async function inviteExternalArtist(artistId) {\r\n  // Generate random token\r\n  const token = Math.random().toString(36).substring(2, 15) +\r\n               Math.random().toString(36).substring(2, 15);\r\n  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days\r\n\r\n  const sql = `\r\n    UPDATE external_artists\r\n    SET\r\n      invitation_token = $1,\r\n      invitation_sent_at = NOW(),\r\n      invitation_expires_at = $2,\r\n      status = 'invited',\r\n      updated_at = NOW()\r\n    WHERE id = $3\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [token, expiresAt, artistId], 'inviteExternalArtist');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Link external artist to clerk user (when they join platform)\r\n *\r\n * @param {string} artistId - External artist ID\r\n * @param {string} clerkUserId - Clerk user ID\r\n * @returns {Promise<object>} Updated external artist\r\n */\r\nexport async function linkExternalArtistToClerk(artistId, clerkUserId) {\r\n  const sql = `\r\n    UPDATE external_artists\r\n    SET\r\n      clerk_user_id = $1,\r\n      status = 'platform',\r\n      updated_at = NOW()\r\n    WHERE id = $2\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [clerkUserId, artistId], 'linkExternalArtistToClerk');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Get unified roster (platform + external artists)\r\n *\r\n * @param {string} labelId - Label ID\r\n * @returns {Promise<Array>} Combined roster\r\n */\r\nexport async function getUnifiedRoster(labelId) {\r\n  const sql = `\r\n    SELECT\r\n      lr.id,\r\n      lr.artist_id,\r\n      lr.name,\r\n      lr.email,\r\n      lr.photo_url,\r\n      lr.status,\r\n      lr.signed_date,\r\n      'platform'::text as artist_type,\r\n      cu.username,\r\n      p.display_name\r\n    FROM label_roster lr\r\n    JOIN clerk_users cu ON cu.id = lr.artist_id\r\n    LEFT JOIN profiles p ON p.user_id = cu.id\r\n    WHERE lr.label_id = $1\r\n\r\n    UNION ALL\r\n\r\n    SELECT\r\n      ea.id,\r\n      NULL::text as artist_id,\r\n      ea.name,\r\n      ea.email,\r\n      NULL::text as photo_url,\r\n      ea.status,\r\n      ea.signed_date,\r\n      'external'::text as artist_type,\r\n      NULL::text as username,\r\n      ea.stage_name as display_name\r\n    FROM external_artists ea\r\n    WHERE ea.label_id = $1\r\n\r\n    ORDER BY signed_date DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [labelId], 'getUnifiedRoster');\r\n}\r\n\r\n// =====================================================\r\n// BUSINESS OVERVIEW METRICS\r\n// =====================================================\r\n\r\n/**\r\n * Get label metrics for business overview\r\n *\r\n * @param {string} labelId - Label ID\r\n * @returns {Promise<object>} Label metrics (total_artists, active_releases, total_revenue, total_streams)\r\n */\r\nexport async function getLabelMetrics(labelId) {\r\n  const sql = `\r\n    WITH artist_counts AS (\r\n      SELECT COUNT(*) as total_artists\r\n      FROM label_roster\r\n      WHERE label_id = $1 AND status = 'active'\r\n    ),\r\n    release_counts AS (\r\n      SELECT COUNT(*) as active_releases\r\n      FROM releases\r\n      WHERE label_id = $1 AND status IN ('distributed', 'submitted')\r\n    ),\r\n    revenue_data AS (\r\n      SELECT COALESCE(SUM(lifetime_earnings), 0) as total_revenue,\r\n             COALESCE(SUM(lifetime_streams), 0) as total_streams\r\n      FROM distribution_stats\r\n      WHERE user_id IN (SELECT artist_id FROM label_roster WHERE label_id = $1)\r\n    )\r\n    SELECT * FROM artist_counts, release_counts, revenue_data\r\n  `;\r\n  const result = await executeQuery(sql, [labelId], 'getLabelMetrics');\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get studio metrics for business overview\r\n *\r\n * @param {string} studioId - Studio ID\r\n * @returns {Promise<object>} Studio metrics (total_rooms, pending_bookings, completed_bookings)\r\n */\r\nexport async function getStudioMetrics(studioId) {\r\n  const sql = `\r\n    WITH room_stats AS (\r\n      SELECT COUNT(*) as total_rooms\r\n      FROM studio_rooms\r\n      WHERE studio_id = $1\r\n    ),\r\n    booking_stats AS (\r\n      SELECT\r\n        COUNT(*) FILTER (WHERE status = 'Pending') as pending_bookings,\r\n        COUNT(*) FILTER (WHERE status = 'Completed') as completed_bookings\r\n      FROM bookings\r\n      WHERE studio_owner_id = $1\r\n    )\r\n    SELECT * FROM room_stats, booking_stats\r\n  `;\r\n  const result = await executeQuery(sql, [studioId], 'getStudioMetrics');\r\n  return result;\r\n}\r\n\r\n/**\r\n * Get distribution metrics for business overview\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<object>} Distribution metrics (total_releases, live_releases, draft_releases)\r\n */\r\nexport async function getDistributionMetrics(userId) {\r\n  const sql = `\r\n    SELECT\r\n      COUNT(*) as total_releases,\r\n      COUNT(*) FILTER (WHERE status = 'Live' OR status = 'distributed') as live_releases,\r\n      COUNT(*) FILTER (WHERE status = 'Draft' OR status = 'draft') as draft_releases\r\n    FROM releases\r\n    WHERE artist_id = $1 OR label_id = $1\r\n  `;\r\n  const result = await executeQuery(sql, [userId], 'getDistributionMetrics');\r\n  return result;\r\n}\r\n\r\n// =====================================================\r\n// EDUCATION QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get student data\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<object|null>} Student data or null\r\n */\r\nexport async function getStudent(userId) {\r\n  const sql = `\r\n    SELECT\r\n      s.*,\r\n      sc.name as school_name,\r\n      sc.logo_url as school_logo\r\n    FROM students s\r\n    LEFT JOIN schools sc ON sc.id = s.school_id\r\n    WHERE s.user_id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId], 'getStudent');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get staff data\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<object|null>} Staff data or null\r\n */\r\nexport async function getStaff(userId) {\r\n  const sql = `\r\n    SELECT\r\n      ss.*,\r\n      sc.name as school_name,\r\n      sc.logo_url as school_logo,\r\n      sr.name as role_name\r\n    FROM school_staff ss\r\n    LEFT JOIN schools sc ON sc.id = ss.school_id\r\n    LEFT JOIN school_roles sr ON sr.id = ss.role_id\r\n    WHERE ss.user_id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [userId], 'getStaff');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get courses for school\r\n *\r\n * @param {string} schoolId - School ID\r\n * @returns {Promise<Array>} Array of courses\r\n */\r\nexport async function getCourses(schoolId) {\r\n  const sql = `\r\n    SELECT\r\n      c.*,\r\n      cu.username as instructor_username,\r\n      prof.display_name as instructor_display_name,\r\n      prof.photo_url as instructor_photo_url\r\n    FROM courses c\r\n    LEFT JOIN clerk_users cu ON cu.id = c.instructor_id\r\n    LEFT JOIN profiles prof ON prof.user_id = cu.id\r\n    WHERE c.school_id = $1\r\n    ORDER BY c.created_at DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [schoolId], 'getCourses');\r\n}\r\n\r\n/**\r\n * Get enrollments for student\r\n *\r\n * @param {string} userId - User ID\r\n * @returns {Promise<Array>} Array of enrollments\r\n */\r\nexport async function getEnrollments(userId) {\r\n  const sql = `\r\n    SELECT\r\n      e.*,\r\n      c.code as course_code,\r\n      c.title as course_title,\r\n      c.credits,\r\n      sc.name as school_name\r\n    FROM enrollments e\r\n    JOIN courses c ON c.id = e.course_id\r\n    LEFT JOIN schools sc ON sc.id = c.school_id\r\n    JOIN students s ON s.id = e.student_id\r\n    WHERE s.user_id = $1\r\n    ORDER BY e.created_at DESC\r\n  `;\r\n\r\n  return executeQuery(sql, [userId], 'getEnrollments');\r\n}\r\n\r\n// =====================================================\r\n// EQUIPMENT DATABASE QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get all verified equipment items grouped by category\r\n *\r\n * @returns {Promise<Array>} All verified equipment items\r\n *\r\n * @example\r\n * const equipment = await getAllEquipment();\r\n */\r\nexport async function getAllEquipment() {\r\n  const sql = `\r\n    SELECT\r\n      id,\r\n      name,\r\n      brand,\r\n      model,\r\n      category,\r\n      subcategory,\r\n      description,\r\n      specifications,\r\n      search_tokens,\r\n      verified,\r\n      created_at\r\n    FROM equipment_database\r\n    WHERE verified = true\r\n    ORDER BY category, subcategory, brand, name\r\n  `;\r\n\r\n  return executeQuery(sql, [], 'getAllEquipment');\r\n}\r\n\r\n/**\r\n * Get equipment by category\r\n *\r\n * @param {string} category - Equipment category\r\n * @returns {Promise<Array>} Equipment items in category\r\n *\r\n * @example\r\n * const mics = await getEquipmentByCategory('Microphones & Transducers');\r\n */\r\nexport async function getEquipmentByCategory(category) {\r\n  const sql = `\r\n    SELECT * FROM equipment_database\r\n    WHERE category = $1 AND verified = true\r\n    ORDER BY subcategory, brand, name\r\n  `;\r\n\r\n  return executeQuery(sql, [category], 'getEquipmentByCategory');\r\n}\r\n\r\n/**\r\n * Get equipment by subcategory\r\n *\r\n * @param {string} category - Equipment category\r\n * @param {string} subcategory - Equipment subcategory\r\n * @returns {Promise<Array>} Equipment items\r\n *\r\n * @example\r\n * const dynamics = await getEquipmentBySubcategory('Microphones & Transducers', 'Dynamic Microphones');\r\n */\r\nexport async function getEquipmentBySubcategory(category, subcategory) {\r\n  const sql = `\r\n    SELECT * FROM equipment_database\r\n    WHERE category = $1 AND subcategory = $2 AND verified = true\r\n    ORDER BY brand, name\r\n  `;\r\n\r\n  return executeQuery(sql, [category, subcategory], 'getEquipmentBySubcategory');\r\n}\r\n\r\n/**\r\n * Search equipment by name, brand, or model\r\n *\r\n * @param {string} searchTerm - Search term\r\n * @param {number} limit - Max results (default: 50)\r\n * @returns {Promise<Array>} Matching equipment items\r\n *\r\n * @example\r\n * const results = await searchEquipment('Neumann');\r\n * const results = await searchEquipment('SM58', 20);\r\n */\r\nexport async function searchEquipment(searchTerm, limit = 50) {\r\n  const sql = `\r\n    SELECT\r\n      id,\r\n      name,\r\n      brand,\r\n      model,\r\n      category,\r\n      subcategory,\r\n      description\r\n    FROM equipment_database\r\n    WHERE verified = true\r\n      AND (\r\n        name ILIKE $1\r\n        OR brand ILIKE $1\r\n        OR model ILIKE $1\r\n        OR $1 = ANY(search_tokens)\r\n      )\r\n    ORDER BY\r\n      CASE\r\n        WHEN name ILIKE $1 THEN 1\r\n        WHEN brand ILIKE $1 THEN 2\r\n        WHEN model ILIKE $1 THEN 3\r\n        ELSE 4\r\n      END,\r\n      name\r\n    LIMIT $2\r\n  `;\r\n\r\n  return executeQuery(sql, [`%${searchTerm}%`, limit], 'searchEquipment');\r\n}\r\n\r\n/**\r\n * Get equipment by ID\r\n *\r\n * @param {string} equipmentId - Equipment ID\r\n * @returns {Promise<object|null>} Equipment item or null\r\n *\r\n * @example\r\n * const equipment = await getEquipmentById('uuid-123');\r\n */\r\nexport async function getEquipmentById(equipmentId) {\r\n  const sql = `\r\n    SELECT * FROM equipment_database\r\n    WHERE id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [equipmentId], 'getEquipmentById');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get equipment grouped by category and subcategory\r\n * Returns a nested structure for autocomplete components\r\n *\r\n * @returns {Promise<object>} Equipment grouped by category and subcategory\r\n *\r\n * @example\r\n * const grouped = await getEquipmentGrouped();\r\n * // Returns: {\r\n * //   \"Microphones & Transducers\": {\r\n * //     \"Dynamic Microphones\": [ ...items ],\r\n * //     \"Condenser Microphones\": { ... }\r\n * //   }\r\n * // }\r\n */\r\nexport async function getEquipmentGrouped() {\r\n  const sql = `\r\n    SELECT\r\n      category,\r\n      subcategory,\r\n      id,\r\n      name,\r\n      brand,\r\n      model,\r\n      description,\r\n      specifications\r\n    FROM equipment_database\r\n    WHERE verified = true\r\n    ORDER BY category, subcategory, brand, name\r\n  `;\r\n\r\n  const items = await executeQuery(sql, [], 'getEquipmentGrouped');\r\n\r\n  // Group by category and subcategory\r\n  const grouped = {};\r\n  items.forEach(item => {\r\n    if (!grouped[item.category]) {\r\n      grouped[item.category] = {};\r\n    }\r\n    if (!grouped[item.category][item.subcategory]) {\r\n      grouped[item.category][item.subcategory] = [];\r\n    }\r\n    grouped[item.category][item.subcategory].push(item);\r\n  });\r\n\r\n  return grouped;\r\n}\r\n\r\n/**\r\n * Get all equipment categories\r\n *\r\n * @returns {Promise<Array>} List of unique categories\r\n *\r\n * @example\r\n * const categories = await getEquipmentCategories();\r\n * // Returns: [\"Microphones & Transducers\", \"Audio Interfaces\", ...]\r\n */\r\nexport async function getEquipmentCategories() {\r\n  const sql = `\r\n    SELECT DISTINCT category\r\n    FROM equipment_database\r\n    WHERE verified = true\r\n    ORDER BY category\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [], 'getEquipmentCategories');\r\n  return result.map(r => r.category);\r\n}\r\n\r\n/**\r\n * Get subcategories for a category\r\n *\r\n * @param {string} category - Equipment category\r\n * @returns {Promise<Array>} List of subcategories\r\n *\r\n * @example\r\n * const subcats = await getEquipmentSubcategories('Microphones & Transducers');\r\n */\r\nexport async function getEquipmentSubcategories(category) {\r\n  const sql = `\r\n    SELECT DISTINCT subcategory\r\n    FROM equipment_database\r\n    WHERE category = $1 AND verified = true\r\n    ORDER BY subcategory\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [category], 'getEquipmentSubcategories');\r\n  return result.map(r => r.subcategory);\r\n}\r\n\r\n// =====================================================\r\n// EQUIPMENT SUBMISSIONS (Community Verification)\r\n// =====================================================\r\n\r\n/**\r\n * Get pending equipment submissions\r\n *\r\n * @param {number} limit - Max results (default: 20)\r\n * @returns {Promise<Array>} Pending submissions\r\n */\r\nexport async function getPendingSubmissions(limit = 20) {\r\n  const sql = `\r\n    SELECT * FROM equipment_submissions\r\n    WHERE status = 'pending'\r\n    ORDER BY timestamp DESC\r\n    LIMIT $1\r\n  `;\r\n\r\n  return executeQuery(sql, [limit], 'getPendingSubmissions');\r\n}\r\n\r\n/**\r\n * Create equipment submission\r\n *\r\n * @param {object} submission - Submission data\r\n * @returns {Promise<object>} Created submission\r\n */\r\nexport async function createEquipmentSubmission(submission) {\r\n  const sql = `\r\n    INSERT INTO equipment_submissions (\r\n      brand, model, category, sub_category, specs,\r\n      submitted_by, submitter_name, status, votes\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n    RETURNING *\r\n  `;\r\n\r\n  const params = [\r\n    submission.brand,\r\n    submission.model,\r\n    submission.category,\r\n    submission.subcategory || null,\r\n    submission.specs,\r\n    submission.submittedBy,\r\n    submission.submitterName || null,\r\n    submission.status || 'pending',\r\n    JSON.stringify(submission.votes || { yes: [], fake: [], duplicate: [] })\r\n  ];\r\n\r\n  const result = await executeQuery(sql, params, 'createEquipmentSubmission');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update equipment submission votes\r\n *\r\n * @param {string} submissionId - Submission ID\r\n * @param {object} votes - Updated votes object\r\n * @returns {Promise<object>} Updated submission\r\n */\r\nexport async function updateSubmissionVotes(submissionId, votes) {\r\n  const sql = `\r\n    UPDATE equipment_submissions\r\n    SET votes = $2\r\n    WHERE id = $1\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [submissionId, JSON.stringify(votes)], 'updateSubmissionVotes');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Approve equipment submission and add to database\r\n *\r\n * @param {string} submissionId - Submission ID\r\n * @param {string} verifiedBy - User ID of verifier\r\n * @returns {Promise<object>} Approved submission\r\n */\r\nexport async function approveEquipmentSubmission(submissionId, verifiedBy) {\r\n  // First get the submission\r\n  const submission = await executeQuery(\r\n    'SELECT * FROM equipment_submissions WHERE id = $1',\r\n    [submissionId],\r\n    'getSubmissionForApproval'\r\n  );\r\n\r\n  if (!submission[0]) {\r\n    throw new Error('Submission not found');\r\n  }\r\n\r\n  const sub = submission[0];\r\n\r\n  // Add to equipment database\r\n  const equipment = await executeQuery(\r\n    `INSERT INTO equipment_database (\r\n      name, brand, model, category, subcategory, verified, verified_by, added_by\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\r\n    RETURNING *`,\r\n    [sub.model, sub.brand, sub.model, sub.category, sub.sub_category, true, [verifiedBy], sub.submitted_by],\r\n    'approveSubmission'\r\n  );\r\n\r\n  // Update submission status\r\n  await executeQuery(\r\n    \"UPDATE equipment_submissions SET status = 'approved' WHERE id = $1\",\r\n    [submissionId],\r\n    'updateSubmissionStatus'\r\n  );\r\n\r\n  return equipment[0];\r\n}\r\n\r\n/**\r\n * Reject equipment submission\r\n *\r\n * @param {string} submissionId - Submission ID\r\n * @returns {Promise<object>} Updated submission\r\n */\r\nexport async function rejectEquipmentSubmission(submissionId) {\r\n  const sql = `\r\n    UPDATE equipment_submissions\r\n    SET status = 'rejected'\r\n    WHERE id = $1\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [submissionId], 'rejectEquipmentSubmission');\r\n  return result[0];\r\n}\r\n\r\n// =====================================================\r\n// INSTRUMENT DATABASE QUERIES\r\n// =====================================================\r\n\r\n/**\r\n * Get all verified instrument items grouped by category\r\n *\r\n * @returns {Promise<Array>} All verified instrument items\r\n *\r\n * @example\r\n * const instruments = await getAllInstruments();\r\n */\r\nexport async function getAllInstruments() {\r\n  const sql = `\r\n    SELECT\r\n      id,\r\n      name,\r\n      brand,\r\n      model,\r\n      category,\r\n      subcategory,\r\n      type,\r\n      series,\r\n      size,\r\n      description,\r\n      specifications,\r\n      search_tokens,\r\n      verified,\r\n      created_at\r\n    FROM instrument_database\r\n    WHERE verified = true\r\n    ORDER BY category, subcategory, brand, name\r\n  `;\r\n\r\n  return executeQuery(sql, [], 'getAllInstruments');\r\n}\r\n\r\n/**\r\n * Get instruments by category\r\n *\r\n * @param {string} category - Instrument category\r\n * @returns {Promise<Array>} Instrument items in category\r\n *\r\n * @example\r\n * const guitars = await getInstrumentsByCategory('String Instruments');\r\n */\r\nexport async function getInstrumentsByCategory(category) {\r\n  const sql = `\r\n    SELECT * FROM instrument_database\r\n    WHERE category = $1 AND verified = true\r\n    ORDER BY subcategory, brand, name\r\n  `;\r\n\r\n  return executeQuery(sql, [category], 'getInstrumentsByCategory');\r\n}\r\n\r\n/**\r\n * Get instruments by subcategory\r\n *\r\n * @param {string} category - Instrument category\r\n * @param {string} subcategory - Instrument subcategory\r\n * @returns {Promise<Array>} Instrument items\r\n *\r\n * @example\r\n * const electrics = await getInstrumentsBySubcategory('String Instruments', 'Electric Guitars');\r\n */\r\nexport async function getInstrumentsBySubcategory(category, subcategory) {\r\n  const sql = `\r\n    SELECT * FROM instrument_database\r\n    WHERE category = $1 AND subcategory = $2 AND verified = true\r\n    ORDER BY brand, name\r\n  `;\r\n\r\n  return executeQuery(sql, [category, subcategory], 'getInstrumentsBySubcategory');\r\n}\r\n\r\n/**\r\n * Get instruments by brand\r\n *\r\n * @param {string} brand - Instrument brand\r\n * @returns {Promise<Array>} Instrument items by brand\r\n *\r\n * @example\r\n * const fenders = await getInstrumentsByBrand('Fender');\r\n */\r\nexport async function getInstrumentsByBrand(brand) {\r\n  const sql = `\r\n    SELECT * FROM instrument_database\r\n    WHERE brand = $1 AND verified = true\r\n    ORDER BY category, subcategory, name\r\n  `;\r\n\r\n  return executeQuery(sql, [brand], 'getInstrumentsByBrand');\r\n}\r\n\r\n/**\r\n * Search instruments by name, brand, or model\r\n *\r\n * @param {string} searchTerm - Search term\r\n * @param {number} limit - Max results (default: 50)\r\n * @returns {Promise<Array>} Matching instrument items\r\n *\r\n * @example\r\n * const results = await searchInstruments('Stratocaster');\r\n * const results = await searchInstruments('SM58', 20);\r\n */\r\nexport async function searchInstruments(searchTerm, limit = 50) {\r\n  const sql = `\r\n    SELECT\r\n      id,\r\n      name,\r\n      brand,\r\n      model,\r\n      category,\r\n      subcategory,\r\n      type,\r\n      series,\r\n      size,\r\n      description\r\n    FROM instrument_database\r\n    WHERE verified = true\r\n      AND (\r\n        name ILIKE $1\r\n        OR brand ILIKE $1\r\n        OR model ILIKE $1\r\n        OR $1 = ANY(search_tokens)\r\n      )\r\n    ORDER BY\r\n      CASE\r\n        WHEN name ILIKE $1 THEN 1\r\n        WHEN brand ILIKE $1 THEN 2\r\n        WHEN model ILIKE $1 THEN 3\r\n        ELSE 4\r\n      END,\r\n      name\r\n    LIMIT $2\r\n  `;\r\n\r\n  return executeQuery(sql, [`%${searchTerm}%`, limit], 'searchInstruments');\r\n}\r\n\r\n/**\r\n * Get instruments by brand and series (for cymbals and other nested categories)\r\n *\r\n * @param {string} category - Category (e.g., 'Percussion Instruments')\r\n * @param {string} subcategory - Subcategory (e.g., 'Cymbals')\r\n * @param {string} brand - Brand (e.g., 'Zildjian')\r\n * @param {string} series - Series (e.g., 'K Custom')\r\n * @returns {Promise<Array>} Instrument items matching brand and series\r\n *\r\n * @example\r\n * const cymbals = await getInstrumentsBySeries('Percussion Instruments', 'Cymbals', 'Zildjian', 'K Custom');\r\n */\r\nexport async function getInstrumentsBySeries(category, subcategory, brand, series) {\r\n  const sql = `\r\n    SELECT * FROM instrument_database\r\n    WHERE category = $1\r\n      AND subcategory = $2\r\n      AND brand = $3\r\n      AND series = $4\r\n      AND verified = true\r\n    ORDER BY type, size\r\n  `;\r\n\r\n  return executeQuery(sql, [category, subcategory, brand, series], 'getInstrumentsBySeries');\r\n}\r\n\r\n/**\r\n * Get instruments by type (e.g., Crash, Ride for cymbals)\r\n *\r\n * @param {string} category - Category\r\n * @param {string} subcategory - Subcategory\r\n * @param {string} brand - Brand\r\n * @param {string} series - Series\r\n * @param {string} type - Type\r\n * @returns {Promise<Array>} Instrument items by type\r\n */\r\nexport async function getInstrumentsByType(category, subcategory, brand, series, type) {\r\n  const sql = `\r\n    SELECT * FROM instrument_database\r\n    WHERE category = $1\r\n      AND subcategory = $2\r\n      AND brand = $3\r\n      AND series = $4\r\n      AND type = $5\r\n      AND verified = true\r\n    ORDER BY size\r\n  `;\r\n\r\n  return executeQuery(sql, [category, subcategory, brand, series, type], 'getInstrumentsByType');\r\n}\r\n\r\n/**\r\n * Get instrument by ID\r\n *\r\n * @param {string} instrumentId - Instrument ID\r\n * @returns {Promise<object|null>} Instrument item or null\r\n *\r\n * @example\r\n * const instrument = await getInstrumentById('uuid-123');\r\n */\r\nexport async function getInstrumentById(instrumentId) {\r\n  const sql = `\r\n    SELECT * FROM instrument_database\r\n    WHERE id = $1\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [instrumentId], 'getInstrumentById');\r\n  return result[0] || null;\r\n}\r\n\r\n/**\r\n * Get instrument grouped by category and subcategory\r\n * Returns a nested structure for autocomplete components\r\n *\r\n * @returns {Promise<object>} Instruments grouped by category and subcategory\r\n *\r\n * @example\r\n * const grouped = await getInstrumentsGrouped();\r\n * // Returns: {\r\n * //   \"String Instruments\": {\r\n * //     \"Electric Guitars\": [ ...items ],\r\n * //     \"Acoustic Guitars\": [ ...items ]\r\n * //   }\r\n * // }\r\n */\r\nexport async function getInstrumentsGrouped() {\r\n  const sql = `\r\n    SELECT\r\n      category,\r\n      subcategory,\r\n      id,\r\n      name,\r\n      brand,\r\n      model,\r\n      type,\r\n      series,\r\n      size,\r\n      description,\r\n      specifications\r\n    FROM instrument_database\r\n    WHERE verified = true\r\n    ORDER BY category, subcategory, brand, name\r\n  `;\r\n\r\n  const items = await executeQuery(sql, [], 'getInstrumentsGrouped');\r\n\r\n  // Group by category and subcategory\r\n  const grouped = {};\r\n  items.forEach(item => {\r\n    if (!grouped[item.category]) {\r\n      grouped[item.category] = {};\r\n    }\r\n    if (!grouped[item.category][item.subcategory]) {\r\n      grouped[item.category][item.subcategory] = [];\r\n    }\r\n    grouped[item.category][item.subcategory].push(item);\r\n  });\r\n\r\n  return grouped;\r\n}\r\n\r\n/**\r\n * Get all instrument categories\r\n *\r\n * @returns {Promise<Array>} List of unique categories\r\n *\r\n * @example\r\n * const categories = await getInstrumentCategories();\r\n * // Returns: [\"String Instruments\", \"Keyboard Instruments\", ...]\r\n */\r\nexport async function getInstrumentCategories() {\r\n  const sql = `\r\n    SELECT DISTINCT category\r\n    FROM instrument_database\r\n    WHERE verified = true\r\n    ORDER BY category\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [], 'getInstrumentCategories');\r\n  return result.map(r => r.category);\r\n}\r\n\r\n/**\r\n * Get subcategories for a category\r\n *\r\n * @param {string} category - Instrument category\r\n * @returns {Promise<Array>} List of subcategories\r\n *\r\n * @example\r\n * const subcats = await getInstrumentSubcategories('String Instruments');\r\n */\r\nexport async function getInstrumentSubcategories(category) {\r\n  const sql = `\r\n    SELECT DISTINCT subcategory\r\n    FROM instrument_database\r\n    WHERE category = $1 AND verified = true\r\n    ORDER BY subcategory\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [category], 'getInstrumentSubcategories');\r\n  return result.map(r => r.subcategory);\r\n}\r\n\r\n/**\r\n * Get brands for a category\r\n *\r\n * @param {string} category - Instrument category\r\n * @returns {Promise<Array>} List of brands\r\n *\r\n * @example\r\n * const brands = await getInstrumentBrands('String Instruments');\r\n */\r\nexport async function getInstrumentBrands(category) {\r\n  const sql = `\r\n    SELECT DISTINCT brand\r\n    FROM instrument_database\r\n    WHERE category = $1 AND verified = true AND brand IS NOT NULL\r\n    ORDER BY brand\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [category], 'getInstrumentBrands');\r\n  return result.map(r => r.brand);\r\n}\r\n\r\n/**\r\n * Get series for a brand in a category\r\n *\r\n * @param {string} category - Instrument category\r\n * @param {string} subcategory - Instrument subcategory\r\n * @param {string} brand - Brand name\r\n * @returns {Promise<Array>} List of series\r\n */\r\nexport async function getInstrumentSeries(category, subcategory, brand) {\r\n  const sql = `\r\n    SELECT DISTINCT series\r\n    FROM instrument_database\r\n    WHERE category = $1\r\n      AND subcategory = $2\r\n      AND brand = $3\r\n      AND verified = true\r\n      AND series IS NOT NULL\r\n    ORDER BY series\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [category, subcategory, brand], 'getInstrumentSeries');\r\n  return result.map(r => r.series);\r\n}\r\n\r\n// =====================================================\r\n// INSTRUMENT SUBMISSIONS (Community Verification)\r\n// =====================================================\r\n\r\n/**\r\n * Get pending instrument submissions\r\n *\r\n * @param {number} limit - Max results (default: 20)\r\n * @returns {Promise<Array>} Pending submissions\r\n */\r\nexport async function getPendingInstrumentSubmissions(limit = 20) {\r\n  const sql = `\r\n    SELECT * FROM instrument_submissions\r\n    WHERE status = 'pending'\r\n    ORDER BY timestamp DESC\r\n    LIMIT $1\r\n  `;\r\n\r\n  return executeQuery(sql, [limit], 'getPendingInstrumentSubmissions');\r\n}\r\n\r\n/**\r\n * Create instrument submission\r\n *\r\n * @param {object} submission - Submission data\r\n * @returns {Promise<object>} Created submission\r\n */\r\nexport async function createInstrumentSubmission(submission) {\r\n  const sql = `\r\n    INSERT INTO instrument_submissions (\r\n      brand, model, category, sub_category, type, series, size, specs,\r\n      submitted_by, submitter_name, status, votes\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\r\n    RETURNING *\r\n  `;\r\n\r\n  const params = [\r\n    submission.brand,\r\n    submission.model,\r\n    submission.category,\r\n    submission.subcategory || null,\r\n    submission.type || null,\r\n    submission.series || null,\r\n    submission.size || null,\r\n    submission.specs,\r\n    submission.submittedBy,\r\n    submission.submitterName || null,\r\n    submission.status || 'pending',\r\n    JSON.stringify(submission.votes || { yes: [], fake: [], duplicate: [] })\r\n  ];\r\n\r\n  const result = await executeQuery(sql, params, 'createInstrumentSubmission');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Update instrument submission votes\r\n *\r\n * @param {string} submissionId - Submission ID\r\n * @param {object} votes - Updated votes object\r\n * @returns {Promise<object>} Updated submission\r\n */\r\nexport async function updateInstrumentSubmissionVotes(submissionId, votes) {\r\n  const sql = `\r\n    UPDATE instrument_submissions\r\n    SET votes = $2\r\n    WHERE id = $1\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [submissionId, JSON.stringify(votes)], 'updateInstrumentSubmissionVotes');\r\n  return result[0];\r\n}\r\n\r\n/**\r\n * Approve instrument submission and add to database\r\n *\r\n * @param {string} submissionId - Submission ID\r\n * @param {string} verifiedBy - User ID of verifier\r\n * @returns {Promise<object>} Approved submission\r\n */\r\nexport async function approveInstrumentSubmission(submissionId, verifiedBy) {\r\n  // First get the submission\r\n  const submission = await executeQuery(\r\n    'SELECT * FROM instrument_submissions WHERE id = $1',\r\n    [submissionId],\r\n    'getInstrumentSubmissionForApproval'\r\n  );\r\n\r\n  if (!submission[0]) {\r\n    throw new Error('Submission not found');\r\n  }\r\n\r\n  const sub = submission[0];\r\n\r\n  // Add to instrument database\r\n  const instrument = await executeQuery(\r\n    `INSERT INTO instrument_database (\r\n      name, brand, model, category, subcategory, type, series, size,\r\n      verified, verified_by, added_by\r\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\r\n    RETURNING *`,\r\n    [sub.model, sub.brand, sub.model, sub.category, sub.sub_category, sub.type, sub.series, sub.size, true, [verifiedBy], sub.submitted_by],\r\n    'approveInstrumentSubmission'\r\n  );\r\n\r\n  // Update submission status\r\n  await executeQuery(\r\n    \"UPDATE instrument_submissions SET status = 'approved' WHERE id = $1\",\r\n    [submissionId],\r\n    'updateInstrumentSubmissionStatus'\r\n  );\r\n\r\n  return instrument[0];\r\n}\r\n\r\n/**\r\n * Reject instrument submission\r\n *\r\n * @param {string} submissionId - Submission ID\r\n * @returns {Promise<object>} Updated submission\r\n */\r\nexport async function rejectInstrumentSubmission(submissionId) {\r\n  const sql = `\r\n    UPDATE instrument_submissions\r\n    SET status = 'rejected'\r\n    WHERE id = $1\r\n    RETURNING *\r\n  `;\r\n\r\n  const result = await executeQuery(sql, [submissionId], 'rejectInstrumentSubmission');\r\n  return result[0];\r\n}\r\n\r\n// =====================================================\r\n// EXPORT QUERY OBJECT (for backward compatibility)\r\n// =====================================================\r\n\r\n/**\r\n * Query collection organized by feature\r\n * Can be used with executeQuery() for predefined queries\r\n */\r\nexport const queries = {\r\n  users: {\r\n    getById: 'SELECT * FROM clerk_users WHERE id = $1',\r\n    getByEmail: 'SELECT * FROM clerk_users WHERE email = $1',\r\n    getByUsername: 'SELECT * FROM clerk_users WHERE username = $1',\r\n    withProfile: `SELECT cu.*, p.* FROM clerk_users cu LEFT JOIN profiles p ON p.user_id = cu.id WHERE cu.id = $1`,\r\n  },\r\n  posts: {\r\n    getById: 'SELECT * FROM posts WHERE id = $1',\r\n    getByUser: 'SELECT * FROM posts WHERE user_id = $1 AND deleted_at IS NULL ORDER BY created_at DESC LIMIT $2',\r\n    getRecent: 'SELECT * FROM posts WHERE deleted_at IS NULL ORDER BY created_at DESC LIMIT $1',\r\n    withUser: `SELECT p.*, cu.username, prof.display_name, prof.photo_url FROM posts p JOIN clerk_users cu ON p.user_id = cu.id LEFT JOIN profiles prof ON prof.user_id = cu.id WHERE p.id = $1`,\r\n  },\r\n  bookings: {\r\n    getById: 'SELECT * FROM bookings WHERE id = $1',\r\n    getByUser: 'SELECT * FROM bookings WHERE (sender_id = $1 OR target_id = $1) ORDER BY created_at DESC LIMIT $2',\r\n    getByStatus: 'SELECT * FROM bookings WHERE (sender_id = $1 OR target_id = $1) AND status = $2 ORDER BY created_at DESC LIMIT $3',\r\n  },\r\n  marketplace: {\r\n    getActiveItems: 'SELECT * FROM market_items WHERE status = \"active\" ORDER BY created_at DESC LIMIT $1',\r\n    getByCategory: 'SELECT * FROM market_items WHERE category = $1 AND status = \"active\" ORDER BY created_at DESC LIMIT $2',\r\n    getBySeller: 'SELECT * FROM market_items WHERE seller_id = $1 ORDER BY created_at DESC LIMIT $2',\r\n  },\r\n  labels: {\r\n    getRoster: `SELECT lr.*, cu.username, prof.display_name FROM label_roster lr JOIN clerk_users cu ON cu.id = lr.artist_id LEFT JOIN profiles prof ON prof.user_id = cu.id WHERE lr.label_id = $1`,\r\n    getReleases: `SELECT r.*, cu.username as artist_username FROM releases r JOIN clerk_users cu ON cu.id = r.artist_id WHERE r.label_id = $1 ORDER BY r.release_date DESC`,\r\n  },\r\n  education: {\r\n    getStudent: `SELECT s.*, sc.name as school_name FROM students s LEFT JOIN schools sc ON sc.id = s.school_id WHERE s.user_id = $1`,\r\n    getStaff: `SELECT ss.*, sc.name as school_name FROM school_staff ss LEFT JOIN schools sc ON sc.id = ss.school_id WHERE ss.user_id = $1`,\r\n    getCourses: `SELECT c.* FROM courses c WHERE c.school_id = $1 ORDER BY c.created_at DESC`,\r\n  },\r\n  equipment: {\r\n    getAll: 'SELECT * FROM equipment_database WHERE verified = true ORDER BY category, subcategory, brand, name',\r\n    byCategory: 'SELECT * FROM equipment_database WHERE category = $1 AND verified = true ORDER BY subcategory, brand, name',\r\n    search: `SELECT id, name, brand, model, category, subcategory FROM equipment_database WHERE verified = true AND (name ILIKE $1 OR brand ILIKE $1 OR model ILIKE $1) ORDER BY name LIMIT $2`,\r\n    grouped: `SELECT category, subcategory, id, name, brand, model FROM equipment_database WHERE verified = true ORDER BY category, subcategory, brand, name`,\r\n    pendingSubmissions: 'SELECT * FROM equipment_submissions WHERE status = \"pending\" ORDER BY timestamp DESC LIMIT $1',\r\n  },\r\n  instruments: {\r\n    getAll: 'SELECT * FROM instrument_database WHERE verified = true ORDER BY category, subcategory, brand, name',\r\n    byCategory: 'SELECT * FROM instrument_database WHERE category = $1 AND verified = true ORDER BY subcategory, brand, name',\r\n    bySubcategory: 'SELECT * FROM instrument_database WHERE category = $1 AND subcategory = $2 AND verified = true ORDER BY brand, name',\r\n    byBrand: 'SELECT * FROM instrument_database WHERE brand = $1 AND verified = true ORDER BY category, subcategory, name',\r\n    search: `SELECT id, name, brand, model, category, subcategory, type, series, size FROM instrument_database WHERE verified = true AND (name ILIKE $1 OR brand ILIKE $1 OR model ILIKE $1) ORDER BY name LIMIT $2`,\r\n    bySeries: `SELECT * FROM instrument_database WHERE category = $1 AND subcategory = $2 AND brand = $3 AND series = $4 AND verified = true ORDER BY type, size`,\r\n    byType: `SELECT * FROM instrument_database WHERE category = $1 AND subcategory = $2 AND brand = $3 AND series = $4 AND type = $5 AND verified = true ORDER BY size`,\r\n    grouped: `SELECT category, subcategory, id, name, brand, model, type, series, size FROM instrument_database WHERE verified = true ORDER BY category, subcategory, brand, name`,\r\n    pendingSubmissions: 'SELECT * FROM instrument_submissions WHERE status = \"pending\" ORDER BY timestamp DESC LIMIT $1',\r\n  },\r\n};\r\n\r\nexport default {\r\n  // User queries\r\n  getUser,\r\n  getUserByEmail,\r\n  getUserByUsername,\r\n  getProfile,\r\n  getUserWithProfile,\r\n  createClerkUser,\r\n  updateProfile,\r\n  upsertSubProfile,\r\n  getSubProfile,\r\n  getSubProfiles,\r\n  searchUsers,\r\n\r\n  // Social feed queries\r\n  getPosts,\r\n  getPost,\r\n  createPost,\r\n  updatePost,\r\n  deletePost,\r\n  getComments,\r\n  createComment,\r\n  deleteComment,\r\n  updatePostCommentCount,\r\n\r\n  // Booking queries\r\n  getBookings,\r\n  getBooking,\r\n  createBooking,\r\n  updateBookingStatus,\r\n\r\n  // Marketplace queries\r\n  getMarketplaceItems,\r\n  getMarketplaceItem,\r\n  createMarketplaceItem,\r\n  searchMarketplaceItems,\r\n\r\n  // Gear exchange queries\r\n  getGearListings,\r\n  getGearListingById,\r\n  createGearListing,\r\n  updateGearListingStatus,\r\n  getGearOrders,\r\n  createGearOrder,\r\n  updateGearOrderStatus,\r\n  getGearOffers,\r\n  createGearOffer,\r\n  respondToGearOffer,\r\n\r\n  // Safe exchange queries\r\n  getSafeExchangeTransactions,\r\n  getSafeExchangeTransactionById,\r\n  createSafeExchangeTransaction,\r\n  updateSafeExchangeTransaction,\r\n  addTransactionPhoto,\r\n\r\n  // SeshFx marketplace queries\r\n  getMarketplaceItemById,\r\n  createMarketplaceItemSeshFx,\r\n  getUserLibrary,\r\n  addToUserLibrary,\r\n  checkItemOwnership,\r\n\r\n  // Distribution queries\r\n  getDistributionReleases,\r\n  getDistributionReleaseById,\r\n  createDistributionRelease,\r\n  updateDistributionRelease,\r\n  deleteDistributionRelease,\r\n\r\n  // Wallet queries\r\n  getWalletBalance,\r\n  upsertWallet,\r\n  createTransaction,\r\n  getTransactions,\r\n\r\n  // Notification queries\r\n  getNotifications,\r\n  getUnreadNotificationCount,\r\n  createNotification,\r\n  markNotificationAsRead,\r\n  markAllNotificationsAsRead,\r\n  deleteNotification,\r\n  clearAllNotifications,\r\n\r\n  // Label queries\r\n  getLabelRoster,\r\n  getLabelReleases,\r\n  getLabelDashboardMetrics,\r\n  getDistributionStats,\r\n  addArtistToRoster,\r\n  isArtistOnRoster,\r\n  updateRosterEntry,\r\n  deleteRosterEntry,\r\n  createRelease,\r\n  updateRelease,\r\n  getArtistCount,\r\n  getUpcomingReleases,\r\n  searchArtists,\r\n\r\n  // External artist queries\r\n  getExternalArtists,\r\n  createExternalArtist,\r\n  updateExternalArtist,\r\n  inviteExternalArtist,\r\n  linkExternalArtistToClerk,\r\n  getUnifiedRoster,\r\n\r\n  // Business overview metrics\r\n  getLabelMetrics,\r\n  getStudioMetrics,\r\n  getDistributionMetrics,\r\n\r\n  // Education queries\r\n  getStudent,\r\n  getStaff,\r\n  getCourses,\r\n  getEnrollments,\r\n\r\n  // Equipment database queries\r\n  getAllEquipment,\r\n  getEquipmentByCategory,\r\n  getEquipmentBySubcategory,\r\n  searchEquipment,\r\n  getEquipmentById,\r\n  getEquipmentGrouped,\r\n  getEquipmentCategories,\r\n  getEquipmentSubcategories,\r\n  getPendingSubmissions,\r\n  createEquipmentSubmission,\r\n  updateSubmissionVotes,\r\n  approveEquipmentSubmission,\r\n  rejectEquipmentSubmission,\r\n\r\n  // Instrument database queries\r\n  getAllInstruments,\r\n  getInstrumentsByCategory,\r\n  getInstrumentsBySubcategory,\r\n  getInstrumentsByBrand,\r\n  searchInstruments,\r\n  getInstrumentsBySeries,\r\n  getInstrumentsByType,\r\n  getInstrumentById,\r\n  getInstrumentsGrouped,\r\n  getInstrumentCategories,\r\n  getInstrumentSubcategories,\r\n  getInstrumentBrands,\r\n  getInstrumentSeries,\r\n  getPendingInstrumentSubmissions,\r\n  createInstrumentSubmission,\r\n  updateInstrumentSubmissionVotes,\r\n  approveInstrumentSubmission,\r\n  rejectInstrumentSubmission,\r\n\r\n  // Query collection\r\n  queries,\r\n};\r\n","import React, { useState, useEffect, useRef, useCallback, lazy, Suspense } from 'react';\r\nimport { useNavigate, useLocation } from 'react-router-dom';\r\nimport { useAuth, useUser, useClerk } from '@clerk/clerk-react';\r\nimport { Loader2 } from 'lucide-react';\r\nimport { Toaster } from 'react-hot-toast';\r\nimport { useSettings, initializeSettingsFromStorage } from './hooks/useSettings';\r\nimport { LanguageProvider } from './contexts/LanguageContext';\r\nimport { getUserWithProfile, updateProfile, createClerkUser } from './config/neonQueries';\r\n\r\n// Lazy load components to avoid initialization order issues\r\nconst AuthWizard = lazy(() => import('./components/AuthWizard'));\r\nconst AppRoutes = lazy(() => import('./routes/AppRoutes'));\r\nconst MainLayout = lazy(() => import('./components/MainLayout'));\r\n\r\nexport default function App() {\r\n  // Clerk authentication hooks\r\n  const { isLoaded: clerkLoaded, isSignedIn, userId } = useAuth();\r\n  const { user } = useUser();\r\n  const clerk = useClerk();\r\n\r\n  const [userData, setUserData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  // These hooks must be called unconditionally at the top level\r\n  const navigate = useNavigate();\r\n  const location = useLocation();\r\n\r\n  // Dark Mode - now synced with user settings\r\n  const [darkMode, setDarkMode] = useState(() => {\r\n    if (typeof window !== 'undefined') {\r\n        return localStorage.getItem('theme') === 'dark' ||\r\n            (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches);\r\n    }\r\n    return false;\r\n  });\r\n\r\n  // Initialize settings from storage on mount\r\n  useEffect(() => {\r\n    const storedSettings = initializeSettingsFromStorage();\r\n    if (storedSettings) {\r\n      // Apply stored settings immediately\r\n      const root = document.documentElement;\r\n\r\n      // Apply theme\r\n      if (storedSettings.theme === 'system') {\r\n        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n        if (prefersDark) {\r\n          root.classList.add('dark');\r\n          setDarkMode(true);\r\n        } else {\r\n          root.classList.remove('dark');\r\n          setDarkMode(false);\r\n        }\r\n      } else if (storedSettings.theme === 'dark') {\r\n        root.classList.add('dark');\r\n        setDarkMode(true);\r\n      } else {\r\n        root.classList.remove('dark');\r\n        setDarkMode(false);\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // Apply settings from userData when it loads\r\n  useEffect(() => {\r\n    if (userData?.settings) {\r\n      const settings = userData.settings;\r\n      const root = document.documentElement;\r\n\r\n      // Apply theme\r\n      if (settings.theme) {\r\n        if (settings.theme === 'system') {\r\n          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n          if (prefersDark) {\r\n            root.classList.add('dark');\r\n            setDarkMode(true);\r\n          } else {\r\n            root.classList.remove('dark');\r\n            setDarkMode(false);\r\n          }\r\n        } else if (settings.theme === 'dark') {\r\n          root.classList.add('dark');\r\n          setDarkMode(true);\r\n        } else {\r\n          root.classList.remove('dark');\r\n          setDarkMode(false);\r\n        }\r\n      }\r\n\r\n      // Apply font size\r\n      if (settings.accessibility?.fontSize) {\r\n        const fontSizes = {\r\n          small: '14px',\r\n          medium: '16px',\r\n          large: '18px',\r\n          xlarge: '20px',\r\n        };\r\n        root.style.fontSize = fontSizes[settings.accessibility.fontSize] || fontSizes.medium;\r\n      }\r\n\r\n      // Apply reduced motion\r\n      if (settings.accessibility?.reducedMotion) {\r\n        root.classList.add('reduce-motion');\r\n        root.style.setProperty('--motion-duration', '0s');\r\n      } else {\r\n        root.classList.remove('reduce-motion');\r\n        root.style.removeProperty('--motion-duration');\r\n      }\r\n\r\n      // Apply high contrast\r\n      if (settings.accessibility?.highContrast) {\r\n        root.classList.add('high-contrast');\r\n      } else {\r\n        root.classList.remove('high-contrast');\r\n      }\r\n\r\n      // Apply language\r\n      if (settings.language) {\r\n        document.documentElement.lang = settings.language;\r\n      }\r\n    }\r\n  }, [userData?.settings]);\r\n\r\n  useEffect(() => {\r\n    if (darkMode) {\r\n        document.documentElement.classList.add('dark');\r\n        localStorage.setItem('theme', 'dark');\r\n    } else {\r\n        document.documentElement.classList.remove('dark');\r\n        localStorage.setItem('theme', 'light');\r\n    }\r\n  }, [darkMode]);\r\n\r\n  const toggleTheme = () => setDarkMode(!darkMode);\r\n\r\n  // --- CLERK AUTH & USER DATA LOADER ---\r\n  useEffect(() => {\r\n    // Wait for Clerk to load\r\n    if (!clerkLoaded) {\r\n      return;\r\n    }\r\n\r\n    let isMounted = true;\r\n\r\n    /**\r\n     * Load user data from Neon database\r\n     * Uses Clerk user ID to fetch profile data\r\n     */\r\n    const loadUserData = async () => {\r\n      if (!userId || !isSignedIn) {\r\n        if (isMounted) {\r\n          setUserData(null);\r\n          setLoading(false);\r\n        }\r\n        return;\r\n      }\r\n\r\n      try {\r\n        // Fetch user with profile from Neon\r\n        const userWithProfile = await getUserWithProfile(userId);\r\n\r\n        if (userWithProfile) {\r\n          // Construct userData object compatible with existing components\r\n          const finalUserData = {\r\n            id: userId,\r\n            firstName: user?.firstName || userWithProfile.first_name || 'User',\r\n            lastName: user?.lastName || userWithProfile.last_name || '',\r\n            email: user?.primaryEmailAddress?.emailAddress || userWithProfile.email || '',\r\n            accountTypes: userWithProfile.account_types || ['Fan'],\r\n            activeProfileRole: userWithProfile.active_role || userWithProfile.account_types?.[0] || 'Fan',\r\n            preferredRole: userWithProfile.preferred_role || userWithProfile.account_types?.[0] || 'Fan',\r\n            photoURL: user?.imageUrl || userWithProfile.photo_url || userWithProfile.avatar_url || null,\r\n            settings: userWithProfile.settings || {},\r\n            effectiveDisplayName: userWithProfile.effective_display_name || user?.firstName || userWithProfile.first_name || 'User',\r\n            zipCode: userWithProfile.zip_code,\r\n            // Additional profile fields\r\n            ...userWithProfile\r\n          };\r\n\r\n          if (isMounted) {\r\n            setUserData(finalUserData);\r\n          }\r\n        } else {\r\n          // Profile doesn't exist - create minimal userData from Clerk user\r\n          const metadata = user?.publicMetadata || {};\r\n          const minimalUserData = {\r\n            id: userId,\r\n            firstName: user?.firstName || metadata.first_name || 'User',\r\n            lastName: user?.lastName || metadata.last_name || '',\r\n            email: user?.primaryEmailAddress?.emailAddress || '',\r\n            accountTypes: metadata.account_types || ['Fan'],\r\n            activeProfileRole: metadata.active_role || 'Fan',\r\n            photoURL: user?.imageUrl || null,\r\n            settings: {},\r\n            effectiveDisplayName: user?.firstName || metadata.first_name || 'User'\r\n          };\r\n\r\n          if (isMounted) {\r\n            setUserData(minimalUserData);\r\n          }\r\n\r\n          // Create user in Neon database if they don't exist\r\n          try {\r\n            console.log('📝 Creating user in Neon database...');\r\n\r\n            const metadata = user?.publicMetadata || {};\r\n\r\n            // First, create the clerk user record\r\n            await createClerkUser({\r\n              id: userId,\r\n              email: user?.primaryEmailAddress?.emailAddress || '',\r\n              phone: user?.primaryPhoneNumber?.phoneNumber || null,\r\n              first_name: user?.firstName || metadata.first_name || null,\r\n              last_name: user?.lastName || metadata.last_name || null,\r\n              username: user?.username || metadata.username || null,\r\n              profile_photo_url: user?.imageUrl || null,\r\n              account_types: metadata.account_types || ['Fan'],\r\n              active_role: metadata.active_role || 'Fan',\r\n              bio: metadata.bio || null,\r\n              zip_code: metadata.zip_code || null,\r\n            });\r\n\r\n            console.log('✅ User created in Neon database');\r\n\r\n            // Then, try to create the extended profile (if needed)\r\n            // Note: This is optional and will only create the profiles table record\r\n            // The clerk_users table is the critical one that was just created\r\n          } catch (err) {\r\n            console.error(\"❌ Failed to create user in Neon:\", err);\r\n            // Don't block the app - user can still function with Clerk data\r\n          }\r\n        }\r\n\r\n        if (isMounted) {\r\n          setLoading(false);\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Error loading user data:\", err);\r\n        // Set minimal userData on error to prevent crashes\r\n        if (isMounted) {\r\n          const metadata = user?.publicMetadata || {};\r\n          setUserData({\r\n            id: userId,\r\n            firstName: user?.firstName || metadata.first_name || 'User',\r\n            lastName: user?.lastName || metadata.last_name || '',\r\n            email: user?.primaryEmailAddress?.emailAddress || '',\r\n            accountTypes: metadata.account_types || ['Fan'],\r\n            activeProfileRole: metadata.active_role || 'Fan',\r\n            photoURL: user?.imageUrl || null,\r\n            settings: {}\r\n          });\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    loadUserData();\r\n\r\n    return () => {\r\n      isMounted = false;\r\n    };\r\n  }, [userId, isSignedIn, clerkLoaded, user]);\r\n\r\n  const handleLogout = useCallback(async () => {\r\n    try {\r\n      console.log('=== APP LOGOUT ===');\r\n\r\n      // Sign out from Clerk - this clears the session\r\n      if (clerk) {\r\n        await clerk.signOut();\r\n        console.log('✅ Clerk signOut successful');\r\n      }\r\n\r\n      // Clear local state\r\n      setUserData(null);\r\n      console.log('✅ Local state cleared');\r\n\r\n      // Navigate to login\r\n      navigate('/login', { replace: true });\r\n      console.log('✅ Navigated to login');\r\n    } catch (err) {\r\n      console.error(\"Logout error:\", err);\r\n      // Even if signOut fails, clear state and redirect\r\n      setUserData(null);\r\n      navigate('/login', { replace: true });\r\n    }\r\n  }, [navigate, clerk]);\r\n\r\n  // Show loading spinner while Clerk loads or userData is being fetched\r\n  if (!clerkLoaded || loading) {\r\n    return (\r\n      <div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\">\r\n        <Loader2 className=\"animate-spin text-brand-blue\" size={48} />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Check if coming from OAuth signup flow\r\n  const isFromSignup = new URLSearchParams(window.location.search).get('intent') === 'signup';\r\n\r\n  // === AUTHENTICATION GUARD ===\r\n  const isAuthenticated = isSignedIn && userId;\r\n  const hasUserData = userData && userData.id;\r\n  const isOnLoginPage = location.pathname === '/login';\r\n  const isTestLoginPage = location.pathname === '/test-login';\r\n\r\n  // CRITICAL: If no user is logged in with Clerk, show AuthWizard\r\n  if (!isAuthenticated && !isOnLoginPage && !isTestLoginPage) {\r\n    return (\r\n      <Suspense fallback={<div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\"><Loader2 className=\"animate-spin text-brand-blue\" size={48} /></div>}>\r\n        <AuthWizard darkMode={darkMode} toggleTheme={toggleTheme} onSuccess={() => navigate('/')} isNewUser={false} />\r\n      </Suspense>\r\n    );\r\n  }\r\n\r\n  // CRITICAL: If user exists but no userData, show loading\r\n  if (isAuthenticated && !hasUserData && !isOnLoginPage && !isTestLoginPage) {\r\n    return (\r\n      <div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\">\r\n        <Loader2 className=\"animate-spin text-brand-blue\" size={48} />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Handle test login page\r\n  if (isTestLoginPage) {\r\n    if (isAuthenticated && hasUserData) {\r\n      navigate('/debug-report', { replace: true });\r\n      return null;\r\n    }\r\n    return (\r\n      <Suspense fallback={<div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\"><Loader2 className=\"animate-spin text-brand-blue\" size={48} /></div>}>\r\n        <AuthWizard darkMode={darkMode} toggleTheme={toggleTheme} onSuccess={() => navigate('/debug-report')} isNewUser={false} />\r\n      </Suspense>\r\n    );\r\n  }\r\n\r\n  // Handle login page\r\n  if (isOnLoginPage) {\r\n    if (isAuthenticated && hasUserData) {\r\n      navigate('/', { replace: true });\r\n      return null;\r\n    }\r\n    return (\r\n      <Suspense fallback={<div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\"><Loader2 className=\"animate-spin text-brand-blue\" size={48} /></div>}>\r\n        <AuthWizard darkMode={darkMode} toggleTheme={toggleTheme} onSuccess={() => navigate('/')} isNewUser={false} />\r\n      </Suspense>\r\n    );\r\n  }\r\n\r\n  // Handle OAuth onboarding\r\n  if (isAuthenticated && !hasUserData && isFromSignup) {\r\n    return (\r\n      <Suspense fallback={<div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\"><Loader2 className=\"animate-spin text-brand-blue\" size={48} /></div>}>\r\n        <AuthWizard user={user} isNewUser={true} darkMode={darkMode} toggleTheme={toggleTheme} onSuccess={() => navigate('/debug-report')} />\r\n      </Suspense>\r\n    );\r\n  }\r\n\r\n  // Require authentication for all other routes\r\n  if (!isAuthenticated || !hasUserData) {\r\n    return (\r\n      <Suspense fallback={<div className=\"h-screen flex items-center justify-center bg-gray-50 dark:bg-[#1a1d21]\"><Loader2 className=\"animate-spin text-brand-blue\" size={48} /></div>}>\r\n        <AuthWizard darkMode={darkMode} toggleTheme={toggleTheme} onSuccess={() => navigate('/')} isNewUser={false} />\r\n      </Suspense>\r\n    );\r\n  }\r\n\r\n  // Render app with full layout (Sidebar + Navbar + Content)\r\n  return (\r\n    <LanguageProvider userData={userData}>\r\n      <div className=\"min-h-screen bg-gray-50 dark:bg-[#1a1d21]\">\r\n        <Toaster position=\"bottom-right\" toastOptions={{ style: { background: '#333', color: '#fff' } }} />\r\n\r\n        {/* Check if we're on a special route that needs different layout */}\r\n        {location.pathname === '/settings' || location.pathname === '/debug-report' ? (\r\n          // Settings and Debug Report use simple layout\r\n          <main className=\"p-6\">\r\n            <Suspense fallback={<div className=\"flex items-center justify-center min-h-screen\"><Loader2 className=\"animate-spin text-brand-blue\" size={32} /></div>}>\r\n              <AppRoutes\r\n                user={{ id: userId, ...user }}\r\n                userData={userData}\r\n                loading={loading}\r\n                darkMode={darkMode}\r\n                toggleTheme={toggleTheme}\r\n                handleLogout={handleLogout}\r\n              />\r\n            </Suspense>\r\n          </main>\r\n        ) : (\r\n          // All other routes use MainLayout with Sidebar + Navbar\r\n          <Suspense fallback={<div className=\"flex items-center justify-center min-h-screen\"><Loader2 className=\"animate-spin text-brand-blue\" size={32} /></div>}>\r\n            <MainLayout\r\n              user={{ id: userId, ...user }}\r\n              userData={userData}\r\n              loading={loading}\r\n              darkMode={darkMode}\r\n              toggleTheme={toggleTheme}\r\n              handleLogout={handleLogout}\r\n            />\r\n          </Suspense>\r\n        )}\r\n      </div>\r\n    </LanguageProvider>\r\n  );\r\n}\r\n","/**\r\n * Clerk Authentication Configuration\r\n *\r\n * This module configures Clerk for authentication, replacing Supabase Auth.\r\n * Clerk provides a complete authentication solution with OAuth, magic links,\r\n * multi-factor authentication, and user management.\r\n *\r\n * Environment Variables Required:\r\n * - VITE_CLERK_PUBLISHABLE_KEY: Clerk publishable key (frontend)\r\n * - VITE_CLERK_SECRET_KEY: Clerk secret key (backend/server-side only)\r\n *\r\n * Clerk Dashboard: https://dashboard.clerk.com/\r\n *\r\n * Documentation: https://clerk.com/docs\r\n */\r\n\r\n// Validate required environment variables\r\nconst clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;\r\n\r\nif (!clerkPubKey) {\r\n  if (import.meta.env.DEV) {\r\n    console.error(\r\n      '❌ Clerk: VITE_CLERK_PUBLISHABLE_KEY is not set. ' +\r\n      'Authentication will not work. Get your key from https://dashboard.clerk.com/'\r\n    );\r\n  } else {\r\n    console.error('❌ Clerk: Missing publishable key in production');\r\n  }\r\n}\r\n\r\n/**\r\n * Clerk Publishable Key\r\n *\r\n * This key is safe to expose in the frontend and is used to initialize\r\n * the Clerk browser SDK.\r\n */\r\nexport { clerkPubKey };\r\n\r\n/**\r\n * Check if Clerk is properly configured\r\n *\r\n * @returns {boolean} True if Clerk publishable key is present\r\n */\r\nexport function isClerkConfigured() {\r\n  return !!clerkPubKey;\r\n}\r\n\r\n/**\r\n * Clerk Configuration Options\r\n *\r\n * These options can be passed to <ClerkProvider> in main.jsx.\r\n * Customize these based on your application's needs.\r\n */\r\nexport const clerkConfig = {\r\n  // Enable Clerk DevTools in development\r\n  publishableKey: clerkPubKey,\r\n\r\n  // Appearance customization\r\n  appearance: {\r\n    // Customize the Clerk components appearance\r\n    elements: {\r\n      // Primary button styling\r\n      primaryButton: {\r\n        backgroundColor: 'hsl(222, 78%, 58%)', // SeshNx primary color #3D84ED\r\n        color: 'white',\r\n        '&:hover': {\r\n          backgroundColor: 'hsl(223, 82%, 57%)', // SeshNx accent color #3C5DE8\r\n        },\r\n      },\r\n      // Input field styling\r\n      input: {\r\n        borderColor: '#e2e8f0',\r\n        '&:focus': {\r\n          borderColor: '#3D84ED',\r\n        },\r\n      },\r\n    },\r\n    // Add custom CSS\r\n    variables: {\r\n      colorPrimary: '#3D84ED',\r\n      colorBackground: 'white',\r\n      colorInputBackground: 'white',\r\n      colorDanger: '#ef4444',\r\n      colorSuccess: '#22c55e',\r\n    },\r\n  },\r\n\r\n  // Enable/disable features\r\n  // See: https://clerk.com/docs/reference/clerk/clerk-provider#props\r\n  // afterSignInUrl: '/dashboard',\r\n  // afterSignUpUrl: '/onboarding',\r\n  // signInForceRedirectUrl: false,\r\n  // signUpForceRedirectUrl: false,\r\n\r\n  // OAuth providers (configure in Clerk Dashboard)\r\n  // supportedOAuthProviders: ['oauth_google', 'oauth_apple', 'oauth_facebook'],\r\n\r\n  // Debug mode (development only)\r\n  debug: import.meta.env.DEV,\r\n};\r\n\r\n/**\r\n * Clerk Metadata Keys\r\n *\r\n * These keys are used to store application-specific metadata in Clerk user objects.\r\n * This metadata will be synced to Aurora profiles table via webhooks.\r\n */\r\nexport const CLERK_METADATA_KEYS = {\r\n  // Basic profile information\r\n  FIRST_NAME: 'first_name',\r\n  LAST_NAME: 'last_name',\r\n  ACCOUNT_TYPES: 'account_types', // Array of role strings\r\n  ACTIVE_ROLE: 'active_role',     // Currently active role\r\n\r\n  // Profile completion\r\n  PROFILE_COMPLETED: 'profile_completed',\r\n  ONBOARDING_COMPLETED: 'onboarding_completed',\r\n\r\n  // Custom fields\r\n  BIO: 'bio',\r\n  ZIP_CODE: 'zip_code',\r\n\r\n  // Timestamps\r\n  LAST_LOGIN: 'last_login',\r\n  PROFILE_UPDATED: 'profile_updated',\r\n};\r\n\r\n/**\r\n * Clerk Webhook Events\r\n *\r\n * These events should be handled in your backend webhook handler\r\n * to sync user data with Aurora profiles table.\r\n */\r\nexport const CLERK_WEBHOOK_EVENTS = {\r\n  USER_CREATED: 'user.created',\r\n  USER_UPDATED: 'user.updated',\r\n  USER_DELETED: 'user.deleted',\r\n  SESSION_CREATED: 'session.created',\r\n  SESSION_ENDED: 'session.ended',\r\n  SESSION_REVOKED: 'session.revoked',\r\n};\r\n\r\n/**\r\n * Example Clerk integration in main.jsx:\r\n *\r\n * import { ClerkProvider } from '@clerk/clerk-react';\r\n * import { clerkConfig } from '@/config/clerk';\r\n * import ReactDOM from 'react-dom/client';\r\n * import App from './App';\r\n * import './index.css';\r\n *\r\n * ReactDOM.createRoot(document.getElementById('root')).render(\r\n *   <React.StrictMode>\r\n *     <ClerkProvider {...clerkConfig}>\r\n *       <App />\r\n *     </ClerkProvider>\r\n *   </React.StrictMode>\r\n * );\r\n */\r\n\r\n/**\r\n * Example usage in components:\r\n *\r\n * import { useAuth, useUser, SignIn, SignUp } from '@clerk/clerk-react';\r\n *\r\n * function MyComponent() {\r\n *   const { isLoaded, isSignedIn, userId } = useAuth();\r\n *   const { user } = useUser();\r\n *\r\n *   if (!isLoaded) return <div>Loading...</div>;\r\n *\r\n *   if (!isSignedIn) {\r\n *     return <SignIn afterSignInUrl=\"/dashboard\" />;\r\n *   }\r\n *\r\n *   return (\r\n *     <div>\r\n *       <p>Welcome, {user?.firstName}!</p>\r\n *       <p>User ID: {userId}</p>\r\n *     </div>\r\n *   );\r\n * }\r\n *\r\n * // Access custom metadata\r\n * const accountTypes = user?.publicMetadata?.account_types || ['Fan'];\r\n * const activeRole = user?.publicMetadata?.active_role || 'Fan';\r\n */\r\n\r\n/**\r\n * Example protected route:\r\n *\r\n * import { SignedIn, SignedOut, RedirectToSignIn } from '@clerk/clerk-react';\r\n *\r\n * function Dashboard() {\r\n *   return (\r\n *     <>\r\n *       <SignedIn>\r\n *         <DashboardContent />\r\n *       </SignedIn>\r\n *       <SignedOut>\r\n *         <RedirectToSignIn />\r\n *       </SignedOut>\r\n *     </>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * JWT Template Configuration for Neon\r\n *\r\n * To integrate Clerk with Neon PostgreSQL, you need to create a JWT template\r\n * in Clerk Dashboard that includes the user ID. This JWT will be passed to Neon\r\n * for authentication and Row Level Security (RLS).\r\n *\r\n * Steps:\r\n * 1. Go to Clerk Dashboard → JWT Templates → New Template\r\n * 2. Name: \"neon-jwt\"\r\n * 3. Claims: Include \"user_id\" claim\r\n * 4. Token lifespan: 5 minutes (recommended)\r\n * 5. Copy the template key to VITE_CLERK_JWT_TEMPLATE env var\r\n *\r\n * Example JWT Template Claims:\r\n * {\r\n *   \"user_id\": \"{{user.id}}\",\r\n *   \"email\": \"{{user.primary_email_address}}\",\r\n *   \"first_name\": \"{{user.first_name}}\",\r\n *   \"last_name\": \"{{user.last_name}}\"\r\n * }\r\n */\r\nexport const CLERK_JWT_TEMPLATE = import.meta.env.VITE_CLERK_JWT_TEMPLATE || 'neon-jwt';\r\n\r\n/**\r\n * Clerk Integration Helpers\r\n */\r\n\r\n/**\r\n * Get the current user's ID from Clerk\r\n * This is useful for database queries that need the user ID\r\n *\r\n * @param {object} auth - Clerk auth object from useAuth()\r\n * @returns {string|null} User ID or null if not authenticated\r\n */\r\nexport function getClerkUserId(auth) {\r\n  return auth?.userId || null;\r\n}\r\n\r\n/**\r\n * Get the current user's metadata from Clerk\r\n *\r\n * @param {object} user - Clerk user object from useUser()\r\n * @returns {object} User metadata (public and unsafe)\r\n */\r\nexport function getClerkUserMetadata(user) {\r\n  if (!user) {\r\n    return {\r\n      accountTypes: ['Fan'],\r\n      activeRole: 'Fan',\r\n      profileCompleted: false,\r\n      onboardingCompleted: false,\r\n    };\r\n  }\r\n\r\n  return {\r\n    // Public metadata (visible to client)\r\n    accountTypes: user?.publicMetadata?.account_types || ['Fan'],\r\n    activeRole: user?.publicMetadata?.active_role || 'Fan',\r\n    profileCompleted: user?.publicMetadata?.profile_completed || false,\r\n    onboardingCompleted: user?.publicMetadata?.onboarding_completed || false,\r\n    bio: user?.publicMetadata?.bio || '',\r\n    zipCode: user?.publicMetadata?.zip_code || '',\r\n\r\n    // Unsafe metadata (only on server)\r\n    // Note: This is only accessible in server-side code\r\n  };\r\n}\r\n\r\n/**\r\n * Check if user has a specific account type\r\n *\r\n * @param {object} user - Clerk user object from useUser()\r\n * @param {string} accountType - Account type to check\r\n * @returns {boolean} True if user has the account type\r\n */\r\nexport function hasAccountType(user, accountType) {\r\n  const accountTypes = user?.publicMetadata?.account_types || [];\r\n  return accountTypes.includes(accountType);\r\n}\r\n\r\n/**\r\n * Check if user has a specific permission\r\n * This is a helper that combines account type checking with permissions\r\n *\r\n * @param {object} user - Clerk user object from useUser()\r\n * @param {string} permission - Permission to check\r\n * @returns {boolean} True if user has the permission\r\n */\r\nexport function hasPermission(user, permission) {\r\n  // Import permissions from utils/permissions.js\r\n  // This would need to be imported at the top of the file\r\n  // For now, return false - implement based on your permission system\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get the user's display name\r\n *\r\n * @param {object} user - Clerk user object from useUser()\r\n * @returns {string} Display name (first name, last name, or username)\r\n */\r\nexport function getUserDisplayName(user) {\r\n  if (!user) return 'Guest';\r\n\r\n  const firstName = user?.firstName;\r\n  const lastName = user?.lastName;\r\n  const username = user?.username;\r\n  const email = user?.primaryEmailAddress?.emailAddress;\r\n\r\n  if (firstName && lastName) {\r\n    return `${firstName} ${lastName}`;\r\n  }\r\n\r\n  if (firstName) {\r\n    return firstName;\r\n  }\r\n\r\n  if (username) {\r\n    return username;\r\n  }\r\n\r\n  if (email) {\r\n    return email.split('@')[0];\r\n  }\r\n\r\n  return 'User';\r\n}\r\n\r\n/**\r\n * Get the user's profile photo URL\r\n *\r\n * @param {object} user - Clerk user object from useUser()\r\n * @returns {string|null} Profile photo URL or null\r\n */\r\nexport function getUserPhotoUrl(user) {\r\n  return user?.imageUrl || null;\r\n}\r\n\r\n/**\r\n * Clerk Error Types\r\n * Map Clerk errors to user-friendly messages\r\n */\r\nexport const CLERK_ERRORS = {\r\n  AUTH_FAILED: 'Authentication failed. Please try again.',\r\n  EMAIL_NOT_VERIFIED: 'Please verify your email address.',\r\n  PASSWORD_TOO_WEAK: 'Password is too weak. Please use a stronger password.',\r\n  EMAIL_ALREADY_EXISTS: 'An account with this email already exists.',\r\n  INVALID_CREDENTIALS: 'Invalid email or password.',\r\n  SESSION_EXPIRED: 'Your session has expired. Please sign in again.',\r\n  VERIFICATION_FAILED: 'Verification failed. Please try again.',\r\n};\r\n\r\n/**\r\n * Get a user-friendly error message from Clerk error\r\n *\r\n * @param {Error} error - Clerk error object\r\n * @returns {string} User-friendly error message\r\n */\r\nexport function getClerkErrorMessage(error) {\r\n  const errorMessages = {\r\n    'form_identifier_exists': CLERK_ERRORS.EMAIL_ALREADY_EXISTS,\r\n    'form_password_pwned': CLERK_ERRORS.PASSWORD_TOO_WEAK,\r\n    'form_password_length_too_short': CLERK_ERRORS.PASSWORD_TOO_WEAK,\r\n    'session_expired': CLERK_ERRORS.SESSION_EXPIRED,\r\n  };\r\n\r\n  const clerkError = error?.errors?.[0];\r\n  const errorCode = clerkError?.code;\r\n\r\n  return errorMessages[errorCode] || CLERK_ERRORS.AUTH_FAILED;\r\n}\r\n\r\n/**\r\n * Clerk OAuth Providers\r\n * Configure these in Clerk Dashboard under \"Configure → Domains → SSO Connections\"\r\n */\r\nexport const CLERK_OAUTH_PROVIDERS = {\r\n  GOOGLE: 'oauth_google',\r\n  APPLE: 'oauth_apple',\r\n  FACEBOOK: 'oauth_facebook',\r\n  GITHUB: 'oauth_github',\r\n  DISCORD: 'oauth_discord',\r\n  SPOTIFY: 'oauth_spotify',\r\n};\r\n\r\n/**\r\n * Get enabled OAuth providers from environment variables\r\n * Format: VITE_CLERK_OAUTH_PROVIDERS=google,apple,github\r\n */\r\nexport function getEnabledOAuthProviders() {\r\n  const providers = import.meta.env.VITE_CLERK_OAUTH_PROVIDERS?.split(',') || [];\r\n  return providers\r\n    .filter(Boolean)\r\n    .map(p => `oauth_${p.toLowerCase().trim()}`);\r\n}\r\n\r\n/**\r\n * Example protected route:\r\n *\r\n * import { SignedIn, SignedOut, RedirectToSignIn } from '@clerk/clerk-react';\r\n *\r\n * function Dashboard() {\r\n *   return (\r\n *     <>\r\n *       <SignedIn>\r\n *         <DashboardContent />\r\n *       </SignedIn>\r\n *       <SignedOut>\r\n *         <RedirectToSignIn />\r\n *       </SignedOut>\r\n *     </>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * Example logout:\r\n *\r\n * import { useSignOut } from '@clerk/clerk-react';\r\n *\r\n * function LogoutButton() {\r\n *   const { signOut } = useSignOut();\r\n *\r\n *   return (\r\n *     <button onClick={() => signOut({ redirectUrl: '/' })}>\r\n *       Sign Out\r\n *     </button>\r\n *   );\r\n * }\r\n */\r\n\r\n/**\r\n * Clerk + Neon Integration Pattern\r\n *\r\n * When querying Neon with Clerk authentication:\r\n *\r\n * 1. Frontend gets JWT from Clerk:\r\n *    const token = await getToken({ template: CLERK_JWT_TEMPLATE });\r\n *\r\n * 2. Backend validates JWT and extracts user_id:\r\n *    const decoded = jwt.verify(token, VITE_CLERK_SECRET_KEY);\r\n *    const userId = decoded.user_id;\r\n *\r\n * 3. Backend sets Neon connection parameter:\r\n *    await neonPool.connect({\r\n *      connectionString: `${neonUrl}?options=project=${neonProjectId}`,\r\n *      statement: `SET LOCAL jwt.claims.user_id = '${userId}';`\r\n *    });\r\n *\r\n * 4. Neon RLS policies use auth.uid() which returns the user_id\r\n */\r\n","/**\r\n * Error Reporting Utility\r\n * \r\n * Centralized error logging and reporting service.\r\n * Supports:\r\n * - Sentry (optional, requires @sentry/react package and VITE_SENTRY_DSN)\r\n * - Local storage for debugging\r\n * - Console logging in development\r\n */\r\n\r\n// Lazy load Sentry to avoid bundling if not used\r\nlet Sentry = null;\r\nlet sentryLoadAttempted = false;\r\n\r\n/**\r\n * Initialize Sentry if available\r\n * @returns {Promise<Object|null>} Sentry module or null if not available\r\n */\r\nconst initSentry = async () => {\r\n  // Return cached result\r\n  if (Sentry !== null) return Sentry;\r\n  if (sentryLoadAttempted) return null;\r\n  \r\n  const dsn = import.meta.env.VITE_SENTRY_DSN;\r\n  if (!dsn) {\r\n    sentryLoadAttempted = true;\r\n    Sentry = false;\r\n    return null;\r\n  }\r\n\r\n  sentryLoadAttempted = true;\r\n\r\n  try {\r\n    // Dynamic import - will fail gracefully if package not installed\r\n    const sentryModule = await import('@sentry/react');\r\n    \r\n    // Real Sentry - proceed with initialization\r\n    Sentry = sentryModule;\r\n    const { init, BrowserTracing, Replay } = sentryModule;\r\n    \r\n    // Check if already initialized\r\n    const hub = sentryModule.getCurrentHub?.();\r\n    if (!hub?.getClient?.()) {\r\n      init({\r\n        dsn,\r\n        environment: import.meta.env.MODE || 'development',\r\n        tracesSampleRate: import.meta.env.PROD ? 0.1 : 1.0,\r\n        replaysSessionSampleRate: import.meta.env.PROD ? 0.1 : 1.0,\r\n        replaysOnErrorSampleRate: 1.0,\r\n        integrations: [\r\n          new BrowserTracing(),\r\n          new Replay(),\r\n        ],\r\n      });\r\n    }\r\n    \r\n    return Sentry;\r\n  } catch (e) {\r\n    // Package not installed or other error - silently fail\r\n    if (import.meta.env.DEV) {\r\n      console.debug('Sentry not available:', e.message);\r\n    }\r\n    Sentry = false;\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Log an error with context\r\n * @param {Error} error - The error object\r\n * @param {Object} errorInfo - Additional error information\r\n * @param {Object} context - Additional context (user, component, etc.)\r\n */\r\nexport const logError = (error, errorInfo = {}, context = {}) => {\r\n  const errorData = {\r\n    message: error?.message || 'Unknown error',\r\n    stack: error?.stack,\r\n    name: error?.name,\r\n    timestamp: new Date().toISOString(),\r\n    userAgent: navigator.userAgent,\r\n    url: window.location.href,\r\n    ...errorInfo,\r\n    context,\r\n  };\r\n\r\n  // Log to console in development\r\n  if (import.meta.env.DEV) {\r\n    console.error('🚨 Error Reported:', errorData);\r\n  }\r\n\r\n  // Send to Sentry if available (async, non-blocking)\r\n  initSentry().then(sentry => {\r\n    if (sentry && sentry.captureException) {\r\n      sentry.captureException(error, {\r\n        extra: errorData,\r\n        tags: {\r\n          component: context.component || 'Unknown',\r\n          errorBoundary: context.errorBoundary || 'None',\r\n        },\r\n        contexts: {\r\n          custom: context,\r\n        },\r\n      });\r\n    }\r\n  }).catch(() => {\r\n    // Ignore Sentry errors\r\n  });\r\n\r\n  // Store errors locally for debugging (limited to last 10)\r\n  try {\r\n    const storedErrors = JSON.parse(localStorage.getItem('seshnx_errors') || '[]');\r\n    storedErrors.unshift(errorData);\r\n    storedErrors.splice(10); // Keep only last 10 errors\r\n    localStorage.setItem('seshnx_errors', JSON.stringify(storedErrors));\r\n  } catch (e) {\r\n    // Ignore localStorage errors\r\n  }\r\n\r\n  return errorData;\r\n};\r\n\r\n/**\r\n * Report a non-error event (warnings, info)\r\n * @param {string} message - The message to report\r\n * @param {string} level - 'warning' | 'info' | 'error'\r\n * @param {Object} context - Additional context\r\n */\r\nexport const reportEvent = (message, level = 'info', context = {}) => {\r\n  const eventData = {\r\n    message,\r\n    level,\r\n    timestamp: new Date().toISOString(),\r\n    url: window.location.href,\r\n    context,\r\n  };\r\n\r\n  if (import.meta.env.DEV) {\r\n    console[level === 'error' ? 'error' : level === 'warning' ? 'warn' : 'log'](\r\n      `📊 Event [${level}]:`,\r\n      eventData\r\n    );\r\n  }\r\n\r\n  // Send to Sentry if available (async, non-blocking)\r\n  initSentry().then(sentry => {\r\n    if (sentry && sentry.captureMessage) {\r\n      sentry.captureMessage(message, {\r\n        level: level === 'error' ? 'error' : level === 'warning' ? 'warning' : 'info',\r\n        extra: eventData,\r\n      });\r\n    }\r\n  }).catch(() => {\r\n    // Ignore Sentry errors\r\n  });\r\n\r\n  return eventData;\r\n};\r\n\r\n/**\r\n * Get stored errors (for debugging)\r\n * @returns {Array} Array of stored errors\r\n */\r\nexport const getStoredErrors = () => {\r\n  try {\r\n    return JSON.parse(localStorage.getItem('seshnx_errors') || '[]');\r\n  } catch (e) {\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Clear stored errors\r\n */\r\nexport const clearStoredErrors = () => {\r\n  try {\r\n    localStorage.removeItem('seshnx_errors');\r\n  } catch (e) {\r\n    // Ignore\r\n  }\r\n};\r\n\r\n","import React from 'react';\nimport { AlertTriangle, RefreshCw, Home, Copy, Check } from 'lucide-react';\nimport { logError } from '../../utils/errorReporting';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      hasError: false, \n      error: null,\n      errorInfo: null,\n      meme: \"Unexpected signal chain failure.\",\n      errorId: null,\n      copied: false\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI.\n    return { \n      hasError: true, \n      error,\n      errorId: `ERR-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log error with full context\n    const context = {\n      componentStack: errorInfo.componentStack,\n      errorBoundary: this.props.name || 'Default',\n      props: this.props.context || {},\n    };\n\n    const loggedError = logError(error, errorInfo, context);\n    \n    // Store error info for display\n    this.setState({ \n      errorInfo: {\n        ...errorInfo,\n        errorId: this.state.errorId || loggedError.timestamp,\n      }\n    });\n  }\n\n  componentDidMount() {\n    // Pre-load a random error meme\n    const phrases = [\n      \"CoreAudio Overload detected.\",\n      \"The plugin crashed the session.\",\n      \"Buffer underrun exception.\",\n      \"Who deleted the master fader?\",\n      \"Sample rate mismatch: Reality is 44.1k, we are 48k.\",\n      \"The drummer kicked the power cable.\",\n      \"Ilok license not found.\",\n      \"Fatal Error: Not enough headroom.\",\n      \"The mix bus is clipping... hard.\",\n      \"Phantom power failure.\"\n    ];\n    this.setState({ meme: phrases[Math.floor(Math.random() * phrases.length)] });\n  }\n\n  handleReset = () => {\n    this.setState({ \n      hasError: false, \n      error: null, \n      errorInfo: null,\n      errorId: null,\n      copied: false\n    });\n    // Optional: Redirect to home/dashboard if recovery isn't possible\n    if (this.props.onReset) {\n      this.props.onReset();\n    } else {\n      // Try to reset to a safe state\n      const currentPath = window.location.pathname;\n      if (currentPath !== '/' && currentPath !== '/dashboard') {\n        window.location.href = '/?tab=dashboard';\n      } else {\n        window.location.reload();\n      }\n    }\n  };\n\n  handleCopyError = async () => {\n    const errorText = `\nError ID: ${this.state.errorId}\nMessage: ${this.state.error?.message || 'Unknown error'}\nStack: ${this.state.error?.stack || 'No stack trace'}\nComponent Stack: ${this.state.errorInfo?.componentStack || 'No component stack'}\nURL: ${window.location.href}\nUser Agent: ${navigator.userAgent}\nTimestamp: ${new Date().toISOString()}\n    `.trim();\n\n    try {\n      await navigator.clipboard.writeText(errorText);\n      this.setState({ copied: true });\n      setTimeout(() => this.setState({ copied: false }), 2000);\n    } catch (err) {\n      console.error('Failed to copy error:', err);\n    }\n  };\n\n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return (\n        <div className=\"min-h-screen bg-[#1f2128] flex flex-col items-center justify-center p-4 text-center text-white font-sans\">\n          <div className=\"bg-[#2c2e36] border border-red-500/30 p-8 rounded-2xl shadow-2xl max-w-lg w-full relative overflow-hidden\">\n            \n            {/* Background Glow */}\n            <div className=\"absolute top-0 left-1/2 -translate-x-1/2 w-32 h-32 bg-red-500/20 blur-[50px] rounded-full pointer-events-none\"></div>\n\n            <div className=\"relative z-10 flex flex-col items-center\">\n              <div className=\"w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mb-6 text-red-500\">\n                <AlertTriangle size={32} strokeWidth={2} />\n              </div>\n\n              <h1 className=\"text-3xl font-bold mb-2\">Session Crashed</h1>\n              \n              <p className=\"text-xl text-[#3D84ED] font-medium mb-6 italic\">\n                \"{this.state.meme}\"\n              </p>\n\n              <div className=\"bg-[#1f2128] p-4 rounded-lg w-full mb-6 text-left border border-gray-700\">\n                <div className=\"flex justify-between items-center mb-2\">\n                  <p className=\"text-xs text-gray-500 uppercase font-bold tracking-wider\">Error Details</p>\n                  <button\n                    onClick={this.handleCopyError}\n                    className=\"text-xs text-gray-400 hover:text-white flex items-center gap-1 transition-colors\"\n                    title=\"Copy error details\"\n                  >\n                    {this.state.copied ? (\n                      <>\n                        <Check size={12} />\n                        Copied!\n                      </>\n                    ) : (\n                      <>\n                        <Copy size={12} />\n                        Copy\n                      </>\n                    )}\n                  </button>\n                </div>\n                <div className=\"space-y-2\">\n                  {this.state.errorId && (\n                    <div>\n                      <span className=\"text-xs text-gray-500\">Error ID: </span>\n                      <code className=\"text-xs text-blue-400 font-mono\">{this.state.errorId}</code>\n                    </div>\n                  )}\n                  <code className=\"text-sm text-red-400 font-mono break-words block\">\n                    {this.state.error?.message || 'Unknown error occurred'}\n                  </code>\n                  {this.state.error?.stack && (\n                    <details className=\"mt-2\">\n                      <summary className=\"text-xs text-gray-500 cursor-pointer hover:text-gray-400\">\n                        Stack Trace\n                      </summary>\n                      <pre className=\"text-xs text-gray-400 font-mono mt-2 overflow-auto max-h-32\">\n                        {this.state.error.stack}\n                      </pre>\n                    </details>\n                  )}\n                </div>\n              </div>\n\n              <div className=\"flex gap-4 w-full\">\n                <button \n                  onClick={() => window.history.back()}\n                  className=\"flex-1 bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-xl font-bold transition-all flex items-center justify-center gap-2\"\n                >\n                  Go Back\n                </button>\n                <button \n                  onClick={this.handleReset}\n                  className=\"flex-1 bg-[#3D84ED] hover:bg-blue-600 text-white py-3 px-4 rounded-xl font-bold transition-all shadow-lg shadow-blue-500/20 flex items-center justify-center gap-2\"\n                >\n                  <RefreshCw size={18} />\n                  Reload App\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children; \n  }\n}\n\nexport default ErrorBoundary;\n","import React from 'react'\r\nimport ReactDOM from 'react-dom/client'\r\nimport { BrowserRouter } from 'react-router-dom'\r\nimport { ConvexProvider } from \"convex/react\"\r\nimport { ClerkProvider } from '@clerk/clerk-react'\r\nimport * as Sentry from '@sentry/react'\r\nimport App from './App.jsx'\r\nimport { convex } from './config/convex'\r\nimport { clerkConfig, clerkPubKey } from './config/clerk'\r\nimport ErrorBoundary from './components/shared/ErrorBoundary'\r\nimport { LanguageProvider } from './contexts/LanguageContext'\r\nimport './index.css'\r\n\r\n// Initialize Sentry if DSN is provided\r\nconst sentryDsn = import.meta.env.VITE_SENTRY_DSN\r\nif (sentryDsn) {\r\n  Sentry.init({\r\n    dsn: sentryDsn,\r\n    environment: import.meta.env.MODE || 'development',\r\n    // Release tracking for better error grouping\r\n    release: import.meta.env.VERCEL_GIT_COMMIT_SHA || 'local-dev',\r\n    integrations: [\r\n      Sentry.browserTracingIntegration({\r\n        // Track navigation performance\r\n        tracePropagationTargets: ['localhost', /^https:\\/\\/(app\\.seshnx\\.com|webapp-main-.*\\.vercel\\.app)/],\r\n      }),\r\n      Sentry.replayIntegration({\r\n        maskAllText: false,\r\n        blockAllMedia: false,\r\n      }),\r\n      Sentry.extraErrorDataIntegration(),\r\n      Sentry.captureConsoleIntegration({\r\n        levels: ['error'],\r\n      }),\r\n    ],\r\n    // Performance Monitoring\r\n    tracesSampleRate: import.meta.env.PROD ? 0.1 : 1.0,\r\n    // Session Replay\r\n    replaysSessionSampleRate: import.meta.env.PROD ? 0.1 : 1.0,\r\n    replaysOnErrorSampleRate: 1.0,\r\n    // Filter out common non-critical errors\r\n    beforeSend(event, hint) {\r\n      // Filter out localStorage errors (tracking prevention)\r\n      if (event.exception?.values?.[0]?.value?.includes('localStorage') ||\r\n          event.exception?.values?.[0]?.value?.includes('QuotaExceededError')) {\r\n        return null; // Don't send these errors\r\n      }\r\n      // Add custom context for all errors\r\n      event.contexts = {\r\n        ...event.contexts,\r\n        app: {\r\n          name: 'SeshNx Webapp',\r\n          environment: import.meta.env.MODE,\r\n        },\r\n      };\r\n      return event;\r\n    },\r\n    // Set user ID when available\r\n    initialScope: {\r\n      tags: {\r\n        framework: 'react',\r\n        runtime: 'vite',\r\n      },\r\n    },\r\n  });\r\n\r\n  if (import.meta.env.DEV) {\r\n    console.log('✓ Sentry initialized for error monitoring');\r\n  }\r\n}\r\n\r\n// Development: Enhanced error logging\r\nif (import.meta.env.DEV) {\r\n  const originalError = console.error;\r\n  console.error = (...args) => {\r\n    const errorMessage = args[0]?.toString() || '';\r\n    if (errorMessage.includes('Rendered more hooks') || errorMessage.includes('301')) {\r\n      console.group('🔴 React Hook Error #301');\r\n      console.error('Component rendered with different hook count than previous render.');\r\n      console.error('Check component stack above for the problematic component.');\r\n      console.groupEnd();\r\n    }\r\n    originalError.apply(console, args);\r\n  };\r\n}\r\n\r\n// App wrapper with error boundaries\r\nconst AppWrapper = ({ children }) => {\r\n  if (sentryDsn) {\r\n    return (\r\n      <Sentry.ErrorBoundary \r\n        fallback={({ error, resetError }) => (\r\n          <div className=\"flex items-center justify-center min-h-screen bg-gray-50 dark:bg-[#1a1d21]\">\r\n            <div className=\"text-center p-8\">\r\n              <h1 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-4\">Something went wrong</h1>\r\n              <p className=\"text-gray-600 dark:text-gray-400 mb-6\">{error?.message || 'An unexpected error occurred'}</p>\r\n              <button\r\n                onClick={resetError}\r\n                className=\"px-4 py-2 bg-brand-blue text-white rounded-lg hover:bg-blue-600 transition-colors\"\r\n              >\r\n                Try again\r\n              </button>\r\n            </div>\r\n          </div>\r\n        )}\r\n      >\r\n        {children}\r\n      </Sentry.ErrorBoundary>\r\n    );\r\n  }\r\n  return <>{children}</>;\r\n};\r\n\r\n// Check if Clerk is configured before rendering\r\nif (!clerkPubKey) {\r\n  console.error(\r\n    '❌ Clerk: VITE_CLERK_PUBLISHABLE_KEY is not set. ' +\r\n    'Get your key from https://dashboard.clerk.com/ ' +\r\n    'and add it to your .env.local file.'\r\n  );\r\n}\r\n\r\nReactDOM.createRoot(document.getElementById('root')).render(\r\n  <AppWrapper>\r\n    <ErrorBoundary name=\"Root\">\r\n      <ClerkProvider {...clerkConfig}>\r\n        <ConvexProvider client={convex}>\r\n          <BrowserRouter>\r\n            <App />\r\n          </BrowserRouter>\r\n        </ConvexProvider>\r\n      </ClerkProvider>\r\n    </ErrorBoundary>\r\n  </AppWrapper>\r\n)\r\n\r\nconst removeLoader = () => {\r\n  const loader = document.getElementById('loading-fallback');\r\n  if (loader) {\r\n    loader.classList.add('fade-out');\r\n    setTimeout(() => {\r\n      if (loader && loader.parentNode) {\r\n        loader.parentNode.removeChild(loader);\r\n      }\r\n      document.body.style.overflow = 'auto';\r\n    }, 400);\r\n  }\r\n};\r\n\r\nsetTimeout(removeLoader, 600);\r\n"],"file":"assets/index-BCKV8ync.js"}