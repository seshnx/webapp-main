{"version":3,"file":"useNotifications-CZI57E4q.js","sources":["../../src/hooks/useNotifications.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { supabase } from '../config/supabase';\r\n\r\n/**\r\n * Notification types:\r\n * - follow: Someone followed you\r\n * - like: Someone reacted to your post\r\n * - comment: Someone commented on your post\r\n * - mention: Someone mentioned you in a post/comment\r\n * - reply: Someone replied to your comment\r\n * - save: Someone saved your post (optional, might be private)\r\n */\r\n\r\n/**\r\n * Hook for managing user notifications\r\n * @param {string} userId - The authenticated user's UID\r\n * @param {number} fetchLimit - Max notifications to fetch (default 50)\r\n */\r\nexport function useNotifications(userId, fetchLimit = 50) {\r\n    const [notifications, setNotifications] = useState([]);\r\n    const [unreadCount, setUnreadCount] = useState(0);\r\n    const [loading, setLoading] = useState(true);\r\n\r\n    // Subscribe to notifications\r\n    useEffect(() => {\r\n        if (!userId || !supabase) {\r\n            setLoading(false);\r\n            return;\r\n        }\r\n\r\n        // Initial fetch\r\n        supabase\r\n            .from('notifications')\r\n            .select('*')\r\n            .eq('user_id', userId)\r\n            .eq('deleted', false)\r\n            .order('created_at', { ascending: false })\r\n            .limit(fetchLimit)\r\n            .then(({ data, error }) => {\r\n                if (error) {\r\n                    console.error('Notifications fetch error:', error);\r\n                    setLoading(false);\r\n                    return;\r\n                }\r\n                \r\n                const notifList = (data || []).map(notif => ({\r\n                    id: notif.id,\r\n                    ...notif,\r\n                    timestamp: notif.created_at,\r\n                    read: notif.read || false\r\n                }));\r\n                setNotifications(notifList);\r\n                setUnreadCount(notifList.filter(n => !n.read).length);\r\n                setLoading(false);\r\n            });\r\n\r\n        // Subscribe to realtime changes\r\n        const channel = supabase\r\n            .channel(`notifications-${userId}`)\r\n            .on(\r\n                'postgres_changes',\r\n                {\r\n                    event: '*',\r\n                    schema: 'public',\r\n                    table: 'notifications',\r\n                    filter: `user_id=eq.${userId}`\r\n                },\r\n                async () => {\r\n                    const { data } = await supabase\r\n                        .from('notifications')\r\n                        .select('*')\r\n                        .eq('user_id', userId)\r\n                        .eq('deleted', false)\r\n                        .order('created_at', { ascending: false })\r\n                        .limit(fetchLimit);\r\n                    \r\n                    if (data) {\r\n                        const notifList = data.map(notif => ({\r\n                            id: notif.id,\r\n                            ...notif,\r\n                            timestamp: notif.created_at,\r\n                            read: notif.read || false\r\n                        }));\r\n                        setNotifications(notifList);\r\n                        setUnreadCount(notifList.filter(n => !n.read).length);\r\n                    }\r\n                }\r\n            )\r\n            .subscribe();\r\n\r\n        return () => {\r\n            supabase.removeChannel(channel);\r\n        };\r\n    }, [userId, fetchLimit]);\r\n\r\n    /**\r\n     * Mark a single notification as read\r\n     */\r\n    const markAsRead = useCallback(async (notificationId) => {\r\n        if (!userId || !supabase) return;\r\n        \r\n        try {\r\n            await supabase\r\n                .from('notifications')\r\n                .update({ read: true })\r\n                .eq('id', notificationId)\r\n                .eq('user_id', userId);\r\n        } catch (error) {\r\n            console.error('Mark as read error:', error);\r\n        }\r\n    }, [userId]);\r\n\r\n    /**\r\n     * Mark all notifications as read\r\n     */\r\n    const markAllAsRead = useCallback(async () => {\r\n        if (!userId || unreadCount === 0 || !supabase) return;\r\n\r\n        try {\r\n            const unreadNotifs = notifications.filter(n => !n.read);\r\n            const notifIds = unreadNotifs.map(n => n.id);\r\n            \r\n            if (notifIds.length > 0) {\r\n                await supabase\r\n                    .from('notifications')\r\n                    .update({ read: true })\r\n                    .in('id', notifIds)\r\n                    .eq('user_id', userId);\r\n            }\r\n        } catch (error) {\r\n            console.error('Mark all as read error:', error);\r\n        }\r\n    }, [userId, notifications, unreadCount]);\r\n\r\n    /**\r\n     * Delete a notification\r\n     */\r\n    const deleteNotification = useCallback(async (notificationId) => {\r\n        if (!userId || !supabase) return;\r\n\r\n        try {\r\n            await supabase\r\n                .from('notifications')\r\n                .update({ deleted: true })\r\n                .eq('id', notificationId)\r\n                .eq('user_id', userId);\r\n        } catch (error) {\r\n            console.error('Delete notification error:', error);\r\n        }\r\n    }, [userId]);\r\n\r\n    /**\r\n     * Clear all notifications (soft delete)\r\n     */\r\n    const clearAll = useCallback(async () => {\r\n        if (!userId || !supabase) return;\r\n\r\n        try {\r\n            const notifIds = notifications.map(n => n.id);\r\n            if (notifIds.length > 0) {\r\n                await supabase\r\n                    .from('notifications')\r\n                    .update({ deleted: true })\r\n                    .in('id', notifIds)\r\n                    .eq('user_id', userId);\r\n            }\r\n        } catch (error) {\r\n            console.error('Clear all error:', error);\r\n        }\r\n    }, [userId, notifications]);\r\n\r\n    return {\r\n        notifications: notifications.filter(n => !n.deleted),\r\n        unreadCount,\r\n        loading,\r\n        markAsRead,\r\n        markAllAsRead,\r\n        deleteNotification,\r\n        clearAll\r\n    };\r\n}\r\n\r\n/**\r\n * Helper function to create notifications (use in other parts of the app)\r\n * Call this when actions happen that should notify users\r\n */\r\nexport async function createNotification({\r\n    targetUserId,\r\n    type,\r\n    fromUserId,\r\n    fromUserName,\r\n    fromUserPhoto,\r\n    postId = null,\r\n    postPreview = null,\r\n    commentId = null,\r\n    message\r\n}) {\r\n    if (!targetUserId || targetUserId === fromUserId || !supabase) return; // Don't notify yourself\r\n\r\n    try {\r\n        await supabase\r\n            .from('notifications')\r\n            .insert({\r\n                user_id: targetUserId,\r\n                type,\r\n                from_user_id: fromUserId,\r\n                from_user_name: fromUserName,\r\n                from_user_photo: fromUserPhoto || null,\r\n                post_id: postId,\r\n                post_preview: postPreview,\r\n                comment_id: commentId,\r\n                message,\r\n                read: false,\r\n                deleted: false,\r\n                created_at: new Date().toISOString()\r\n            });\r\n    } catch (error) {\r\n        console.error('Create notification error:', error);\r\n    }\r\n}\r\n\r\n/**\r\n * Notification message templates\r\n */\r\nexport const NOTIFICATION_MESSAGES = {\r\n    follow: 'started following you',\r\n    like: 'reacted to your post',\r\n    comment: 'commented on your post',\r\n    mention: 'mentioned you',\r\n    reply: 'replied to your comment',\r\n    save: 'saved your post'\r\n};\r\n\r\n/**\r\n * Get notification icon based on type\r\n */\r\nexport const getNotificationIcon = (type) => {\r\n    const icons = {\r\n        follow: 'UserPlus',\r\n        like: 'Heart',\r\n        comment: 'MessageCircle',\r\n        mention: 'AtSign',\r\n        reply: 'CornerDownRight',\r\n        save: 'Bookmark'\r\n    };\r\n    return icons[type] || 'Bell';\r\n};\r\n\r\n"],"names":["useNotifications","userId","fetchLimit","notifications","setNotifications","useState","unreadCount","setUnreadCount","loading","setLoading","useEffect","markAsRead","useCallback","notificationId","markAllAsRead","deleteNotification","clearAll","n"],"mappings":"yCAkBO,SAASA,EAAiBC,EAAQC,EAAa,GAAI,CACtD,KAAM,CAACC,EAAeC,CAAgB,EAAIC,EAAAA,SAAS,CAAA,CAAE,EAC/C,CAACC,EAAaC,CAAc,EAAIF,EAAAA,SAAS,CAAC,EAC1C,CAACG,EAASC,CAAU,EAAIJ,EAAAA,SAAS,EAAI,EAG3CK,EAAAA,UAAU,IAAM,CACc,CACtBD,EAAW,EAAK,EAChB,MACJ,CAiEJ,EAAG,CAACR,EAAQC,CAAU,CAAC,EAKvB,MAAMS,EAAaC,cAAY,MAAOC,GAAmB,CAYzD,EAAG,CAACZ,CAAM,CAAC,EAKLa,EAAgBF,EAAAA,YAAY,SAAY,CAiB9C,EAAG,CAACX,EAAQE,EAAeG,CAAW,CAAC,EAKjCS,EAAqBH,cAAY,MAAOC,GAAmB,CAYjE,EAAG,CAACZ,CAAM,CAAC,EAKLe,EAAWJ,EAAAA,YAAY,SAAY,CAezC,EAAG,CAACX,EAAQE,CAAa,CAAC,EAE1B,MAAO,CACH,cAAeA,EAAc,OAAOc,GAAK,CAACA,EAAE,OAAO,EACnD,YAAAX,EACA,QAAAE,EACA,WAAAG,EACA,cAAAG,EACA,mBAAAC,EACA,SAAAC,CACR,CACA"}